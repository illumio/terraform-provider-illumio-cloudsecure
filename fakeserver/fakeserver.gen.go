// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0
// Code generated by fakeservergen. DO NOT EDIT.

package main

import (
	"context"
	"sync"

	"github.com/google/uuid"
	configv1 "github.com/illumio/terraform-provider-illumio-cloudsecure/api/illumio/cloud/config/v1"
	"go.uber.org/zap"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
)

// FakeConfigServer is a fake server implementation of ConfigService that can be used for testing API clients.
type FakeConfigServer struct {
	configv1.UnimplementedConfigServiceServer
	Logger                              *zap.Logger
	ApplicationMap                      map[string]*Application
	ApplicationMutex                    sync.RWMutex
	ApplicationAwsResourcesMap          map[string]*ApplicationAwsResources
	ApplicationAwsResourcesMutex        sync.RWMutex
	ApplicationAzureResourcesMap        map[string]*ApplicationAzureResources
	ApplicationAzureResourcesMutex      sync.RWMutex
	ApplicationPolicyRuleMap            map[string]*ApplicationPolicyRule
	ApplicationPolicyRuleMutex          sync.RWMutex
	AwsAccountMap                       map[string]*AwsAccount
	AwsAccountMutex                     sync.RWMutex
	AwsFlowLogsS3BucketMap              map[string]*AwsFlowLogsS3Bucket
	AwsFlowLogsS3BucketMutex            sync.RWMutex
	AzureFlowLogsStorageAccountMap      map[string]*AzureFlowLogsStorageAccount
	AzureFlowLogsStorageAccountMutex    sync.RWMutex
	AzureSubscriptionMap                map[string]*AzureSubscription
	AzureSubscriptionMutex              sync.RWMutex
	DeploymentMap                       map[string]*Deployment
	DeploymentMutex                     sync.RWMutex
	IpListMap                           map[string]*IpList
	IpListMutex                         sync.RWMutex
	K8SClusterMap                       map[string]*K8SCluster
	K8SClusterMutex                     sync.RWMutex
	K8SClusterOnboardingCredentialMap   map[string]*K8SClusterOnboardingCredential
	K8SClusterOnboardingCredentialMutex sync.RWMutex
	TagToLabelMap                       map[string]*TagToLabel
	TagToLabelMutex                     sync.RWMutex
}

var _ configv1.ConfigServiceServer = &FakeConfigServer{}

// NewFakeConfigServer creates a fake server implementation of ConfigService that can be used for testing API clients.
func NewFakeConfigServer(logger *zap.Logger) configv1.ConfigServiceServer {
	return &FakeConfigServer{
		Logger:                            logger,
		ApplicationMap:                    make(map[string]*Application),
		ApplicationAwsResourcesMap:        make(map[string]*ApplicationAwsResources),
		ApplicationAzureResourcesMap:      make(map[string]*ApplicationAzureResources),
		ApplicationPolicyRuleMap:          make(map[string]*ApplicationPolicyRule),
		AwsAccountMap:                     make(map[string]*AwsAccount),
		AwsFlowLogsS3BucketMap:            make(map[string]*AwsFlowLogsS3Bucket),
		AzureFlowLogsStorageAccountMap:    make(map[string]*AzureFlowLogsStorageAccount),
		AzureSubscriptionMap:              make(map[string]*AzureSubscription),
		DeploymentMap:                     make(map[string]*Deployment),
		IpListMap:                         make(map[string]*IpList),
		K8SClusterMap:                     make(map[string]*K8SCluster),
		K8SClusterOnboardingCredentialMap: make(map[string]*K8SClusterOnboardingCredential),
		TagToLabelMap:                     make(map[string]*TagToLabel),
	}
}

type Application struct {
	Id           string
	DeploymentId string
	Description  *string
	Name         string
}

type ApplicationAwsResources struct {
	Id                                     string
	AccountId                              string
	ApplicationId                          string
	ApplicationResourceIds                 []string
	Arns                                   []string
	AwsCustomerGatewayIds                  []string
	AwsDxConnectionIds                     []string
	AwsDxVirtualInterfaceIds               []string
	AwsEbsVolumeIds                        []string
	AwsEc2InstanceConnectEndpointIds       []string
	AwsEc2TransitGatewayAttachmentIds      []string
	AwsEc2TransitGatewayIds                []string
	AwsEc2TransitGatewayMulticastDomainIds []string
	AwsEc2TransitGatewayRouteTableIds      []string
	AwsEgressOnlyInternetGatewayIds        []string
	AwsEipIds                              []string
	AwsFlowLogIds                          []string
	AwsInstancesIds                        []string
	AwsInternetGatewayIds                  []string
	AwsNatGatewayIds                       []string
	AwsNetworkAclIds                       []string
	AwsNetworkInterfaceIds                 []string
	AwsRdsClusterIds                       []string
	AwsRouteTableIds                       []string
	AwsSecurityGroupIds                    []string
	AwsSecurityGroupRuleIds                []string
	AwsSpotFleetRequestIds                 []string
	AwsSpotInstanceRequestIds              []string
	AwsSubnetIds                           []string
	AwsVpcEndpointIds                      []string
	AwsVpcEndpointServiceIds               []string
	AwsVpcIds                              []string
	AwsVpcPeeringConnectionIds             []string
	AwsVpnConnectionIds                    []string
	AwsVpnGatewayIds                       []string
}

type ApplicationAzureResources struct {
	Id                     string
	ApplicationId          string
	ApplicationResourceIds []string
	ResourceIds            []string
	SubscriptionId         string
}

type ApplicationPolicyRule struct {
	Id            string
	Action        string
	ApplicationId string
	Description   *string
	ExternalScope *bool
	FromIpListIds []string
	FromLabels    []*configv1.ApplicationPolicyRule_FromLabels
	ToIpListIds   []string
	ToLabels      []*configv1.ApplicationPolicyRule_ToLabels
	ToPortRanges  []*configv1.ApplicationPolicyRule_ToPortRanges
}

type AwsAccount struct {
	Id             string
	AccountId      string
	Mode           string
	Name           string
	OrganizationId *string
	RoleArn        string
	RoleExternalId string
}

type AwsFlowLogsS3Bucket struct {
	Id          string
	AccountId   string
	S3BucketArn string
}

type AzureFlowLogsStorageAccount struct {
	Id                       string
	StorageAccountResourceId string
	SubscriptionId           string
}

type AzureSubscription struct {
	Id             string
	ClientId       string
	ClientSecret   string
	Mode           string
	Name           string
	SubscriptionId string
	TenantId       string
}

type Deployment struct {
	Id                   string
	AwsAccountIds        []string
	AwsRegions           []string
	AwsSubnetIds         []string
	AwsTags              []*configv1.Deployment_AwsTags
	AwsVpcIds            []string
	AzureRegions         []string
	AzureSubnetIds       []string
	AzureSubscriptionIds []string
	AzureTags            []*configv1.Deployment_AzureTags
	AzureVnetIds         []string
	Description          *string
	Name                 string
}

type IpList struct {
	Id          string
	Description *string
	IpAddresses []*configv1.IpList_IpAddresses
	IpRanges    []*configv1.IpList_IpRanges
	Name        string
}

type K8SCluster struct {
	Id            string
	ClientId      string
	ClientSecret  string
	IllumioRegion string
}

type K8SClusterOnboardingCredential struct {
	Id            string
	ClientId      string
	ClientSecret  string
	CreatedAt     string
	Description   *string
	IllumioRegion string
	Name          string
}

type TagToLabel struct {
	Id           string
	AwsTagKeys   []string
	AzureTagKeys []string
	Icon         *configv1.TagToLabel_Icon
	Key          string
	Name         string
}

func (s *FakeConfigServer) CreateApplication(ctx context.Context, req *configv1.CreateApplicationRequest) (*configv1.CreateApplicationResponse, error) {
	id := uuid.New().String()
	model := &Application{
		Id:           id,
		DeploymentId: req.DeploymentId,
		Description:  req.Description,
		Name:         req.Name,
	}
	resp := &configv1.CreateApplicationResponse{
		Id:           id,
		DeploymentId: model.DeploymentId,
		Description:  model.Description,
		Name:         model.Name,
	}
	s.ApplicationMutex.Lock()
	s.ApplicationMap[id] = model
	s.ApplicationMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "application"),
		zap.String("method", "CreateApplication"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadApplication(ctx context.Context, req *configv1.ReadApplicationRequest) (*configv1.ReadApplicationResponse, error) {
	id := req.Id
	s.ApplicationMutex.RLock()
	model, found := s.ApplicationMap[id]
	if !found {
		s.ApplicationMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "application"),
			zap.String("method", "ReadApplication"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application found with id %s", id)
	}
	resp := &configv1.ReadApplicationResponse{
		Id:           id,
		DeploymentId: model.DeploymentId,
		Description:  model.Description,
		Name:         model.Name,
	}
	s.ApplicationMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "application"),
		zap.String("method", "ReadApplication"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateApplication(ctx context.Context, req *configv1.UpdateApplicationRequest) (*configv1.UpdateApplicationResponse, error) {
	id := req.Id
	s.ApplicationMutex.Lock()
	model, found := s.ApplicationMap[id]
	if !found {
		s.ApplicationMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "application"),
			zap.String("method", "UpdateApplication"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "description":
			model.Description = req.Description
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "application"),
				zap.String("method", "UpdateApplication"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for application: %s", path)
		}
	}
	resp := &configv1.UpdateApplicationResponse{
		Id:           id,
		DeploymentId: model.DeploymentId,
		Description:  model.Description,
		Name:         model.Name,
	}
	s.ApplicationMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "application"),
		zap.String("method", "UpdateApplication"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteApplication(ctx context.Context, req *configv1.DeleteApplicationRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.ApplicationMutex.Lock()
	_, found := s.ApplicationMap[id]
	if !found {
		s.ApplicationMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "application"),
			zap.String("method", "DeleteApplication"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application found with id %s", id)
	}
	delete(s.ApplicationMap, id)
	s.ApplicationMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "application"),
		zap.String("method", "DeleteApplication"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateApplicationAwsResources(ctx context.Context, req *configv1.CreateApplicationAwsResourcesRequest) (*configv1.CreateApplicationAwsResourcesResponse, error) {
	id := uuid.New().String()
	model := &ApplicationAwsResources{
		Id:                                     id,
		AccountId:                              req.AccountId,
		ApplicationId:                          req.ApplicationId,
		Arns:                                   req.Arns,
		AwsCustomerGatewayIds:                  req.AwsCustomerGatewayIds,
		AwsDxConnectionIds:                     req.AwsDxConnectionIds,
		AwsDxVirtualInterfaceIds:               req.AwsDxVirtualInterfaceIds,
		AwsEbsVolumeIds:                        req.AwsEbsVolumeIds,
		AwsEc2InstanceConnectEndpointIds:       req.AwsEc2InstanceConnectEndpointIds,
		AwsEc2TransitGatewayAttachmentIds:      req.AwsEc2TransitGatewayAttachmentIds,
		AwsEc2TransitGatewayIds:                req.AwsEc2TransitGatewayIds,
		AwsEc2TransitGatewayMulticastDomainIds: req.AwsEc2TransitGatewayMulticastDomainIds,
		AwsEc2TransitGatewayRouteTableIds:      req.AwsEc2TransitGatewayRouteTableIds,
		AwsEgressOnlyInternetGatewayIds:        req.AwsEgressOnlyInternetGatewayIds,
		AwsEipIds:                              req.AwsEipIds,
		AwsFlowLogIds:                          req.AwsFlowLogIds,
		AwsInstancesIds:                        req.AwsInstancesIds,
		AwsInternetGatewayIds:                  req.AwsInternetGatewayIds,
		AwsNatGatewayIds:                       req.AwsNatGatewayIds,
		AwsNetworkAclIds:                       req.AwsNetworkAclIds,
		AwsNetworkInterfaceIds:                 req.AwsNetworkInterfaceIds,
		AwsRdsClusterIds:                       req.AwsRdsClusterIds,
		AwsRouteTableIds:                       req.AwsRouteTableIds,
		AwsSecurityGroupIds:                    req.AwsSecurityGroupIds,
		AwsSecurityGroupRuleIds:                req.AwsSecurityGroupRuleIds,
		AwsSpotFleetRequestIds:                 req.AwsSpotFleetRequestIds,
		AwsSpotInstanceRequestIds:              req.AwsSpotInstanceRequestIds,
		AwsSubnetIds:                           req.AwsSubnetIds,
		AwsVpcEndpointIds:                      req.AwsVpcEndpointIds,
		AwsVpcEndpointServiceIds:               req.AwsVpcEndpointServiceIds,
		AwsVpcIds:                              req.AwsVpcIds,
		AwsVpcPeeringConnectionIds:             req.AwsVpcPeeringConnectionIds,
		AwsVpnConnectionIds:                    req.AwsVpnConnectionIds,
		AwsVpnGatewayIds:                       req.AwsVpnGatewayIds,
	}
	resp := &configv1.CreateApplicationAwsResourcesResponse{
		Id:                                     id,
		AccountId:                              model.AccountId,
		ApplicationId:                          model.ApplicationId,
		ApplicationResourceIds:                 model.ApplicationResourceIds,
		Arns:                                   model.Arns,
		AwsCustomerGatewayIds:                  model.AwsCustomerGatewayIds,
		AwsDxConnectionIds:                     model.AwsDxConnectionIds,
		AwsDxVirtualInterfaceIds:               model.AwsDxVirtualInterfaceIds,
		AwsEbsVolumeIds:                        model.AwsEbsVolumeIds,
		AwsEc2InstanceConnectEndpointIds:       model.AwsEc2InstanceConnectEndpointIds,
		AwsEc2TransitGatewayAttachmentIds:      model.AwsEc2TransitGatewayAttachmentIds,
		AwsEc2TransitGatewayIds:                model.AwsEc2TransitGatewayIds,
		AwsEc2TransitGatewayMulticastDomainIds: model.AwsEc2TransitGatewayMulticastDomainIds,
		AwsEc2TransitGatewayRouteTableIds:      model.AwsEc2TransitGatewayRouteTableIds,
		AwsEgressOnlyInternetGatewayIds:        model.AwsEgressOnlyInternetGatewayIds,
		AwsEipIds:                              model.AwsEipIds,
		AwsFlowLogIds:                          model.AwsFlowLogIds,
		AwsInstancesIds:                        model.AwsInstancesIds,
		AwsInternetGatewayIds:                  model.AwsInternetGatewayIds,
		AwsNatGatewayIds:                       model.AwsNatGatewayIds,
		AwsNetworkAclIds:                       model.AwsNetworkAclIds,
		AwsNetworkInterfaceIds:                 model.AwsNetworkInterfaceIds,
		AwsRdsClusterIds:                       model.AwsRdsClusterIds,
		AwsRouteTableIds:                       model.AwsRouteTableIds,
		AwsSecurityGroupIds:                    model.AwsSecurityGroupIds,
		AwsSecurityGroupRuleIds:                model.AwsSecurityGroupRuleIds,
		AwsSpotFleetRequestIds:                 model.AwsSpotFleetRequestIds,
		AwsSpotInstanceRequestIds:              model.AwsSpotInstanceRequestIds,
		AwsSubnetIds:                           model.AwsSubnetIds,
		AwsVpcEndpointIds:                      model.AwsVpcEndpointIds,
		AwsVpcEndpointServiceIds:               model.AwsVpcEndpointServiceIds,
		AwsVpcIds:                              model.AwsVpcIds,
		AwsVpcPeeringConnectionIds:             model.AwsVpcPeeringConnectionIds,
		AwsVpnConnectionIds:                    model.AwsVpnConnectionIds,
		AwsVpnGatewayIds:                       model.AwsVpnGatewayIds,
	}
	s.ApplicationAwsResourcesMutex.Lock()
	s.ApplicationAwsResourcesMap[id] = model
	s.ApplicationAwsResourcesMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "application_aws_resources"),
		zap.String("method", "CreateApplicationAwsResources"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadApplicationAwsResources(ctx context.Context, req *configv1.ReadApplicationAwsResourcesRequest) (*configv1.ReadApplicationAwsResourcesResponse, error) {
	id := req.Id
	s.ApplicationAwsResourcesMutex.RLock()
	model, found := s.ApplicationAwsResourcesMap[id]
	if !found {
		s.ApplicationAwsResourcesMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "application_aws_resources"),
			zap.String("method", "ReadApplicationAwsResources"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_aws_resources found with id %s", id)
	}
	resp := &configv1.ReadApplicationAwsResourcesResponse{
		Id:                                     id,
		AccountId:                              model.AccountId,
		ApplicationId:                          model.ApplicationId,
		ApplicationResourceIds:                 model.ApplicationResourceIds,
		Arns:                                   model.Arns,
		AwsCustomerGatewayIds:                  model.AwsCustomerGatewayIds,
		AwsDxConnectionIds:                     model.AwsDxConnectionIds,
		AwsDxVirtualInterfaceIds:               model.AwsDxVirtualInterfaceIds,
		AwsEbsVolumeIds:                        model.AwsEbsVolumeIds,
		AwsEc2InstanceConnectEndpointIds:       model.AwsEc2InstanceConnectEndpointIds,
		AwsEc2TransitGatewayAttachmentIds:      model.AwsEc2TransitGatewayAttachmentIds,
		AwsEc2TransitGatewayIds:                model.AwsEc2TransitGatewayIds,
		AwsEc2TransitGatewayMulticastDomainIds: model.AwsEc2TransitGatewayMulticastDomainIds,
		AwsEc2TransitGatewayRouteTableIds:      model.AwsEc2TransitGatewayRouteTableIds,
		AwsEgressOnlyInternetGatewayIds:        model.AwsEgressOnlyInternetGatewayIds,
		AwsEipIds:                              model.AwsEipIds,
		AwsFlowLogIds:                          model.AwsFlowLogIds,
		AwsInstancesIds:                        model.AwsInstancesIds,
		AwsInternetGatewayIds:                  model.AwsInternetGatewayIds,
		AwsNatGatewayIds:                       model.AwsNatGatewayIds,
		AwsNetworkAclIds:                       model.AwsNetworkAclIds,
		AwsNetworkInterfaceIds:                 model.AwsNetworkInterfaceIds,
		AwsRdsClusterIds:                       model.AwsRdsClusterIds,
		AwsRouteTableIds:                       model.AwsRouteTableIds,
		AwsSecurityGroupIds:                    model.AwsSecurityGroupIds,
		AwsSecurityGroupRuleIds:                model.AwsSecurityGroupRuleIds,
		AwsSpotFleetRequestIds:                 model.AwsSpotFleetRequestIds,
		AwsSpotInstanceRequestIds:              model.AwsSpotInstanceRequestIds,
		AwsSubnetIds:                           model.AwsSubnetIds,
		AwsVpcEndpointIds:                      model.AwsVpcEndpointIds,
		AwsVpcEndpointServiceIds:               model.AwsVpcEndpointServiceIds,
		AwsVpcIds:                              model.AwsVpcIds,
		AwsVpcPeeringConnectionIds:             model.AwsVpcPeeringConnectionIds,
		AwsVpnConnectionIds:                    model.AwsVpnConnectionIds,
		AwsVpnGatewayIds:                       model.AwsVpnGatewayIds,
	}
	s.ApplicationAwsResourcesMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "application_aws_resources"),
		zap.String("method", "ReadApplicationAwsResources"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateApplicationAwsResources(ctx context.Context, req *configv1.UpdateApplicationAwsResourcesRequest) (*configv1.UpdateApplicationAwsResourcesResponse, error) {
	id := req.Id
	s.ApplicationAwsResourcesMutex.Lock()
	model, found := s.ApplicationAwsResourcesMap[id]
	if !found {
		s.ApplicationAwsResourcesMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "application_aws_resources"),
			zap.String("method", "UpdateApplicationAwsResources"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_aws_resources found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "account_id":
			model.AccountId = req.AccountId
		case "application_id":
			model.ApplicationId = req.ApplicationId
		case "application_resource_ids":
			model.ApplicationResourceIds = req.ApplicationResourceIds
		case "arns":
			model.Arns = req.Arns
		case "aws_customer_gateway_ids":
			model.AwsCustomerGatewayIds = req.AwsCustomerGatewayIds
		case "aws_dx_connection_ids":
			model.AwsDxConnectionIds = req.AwsDxConnectionIds
		case "aws_dx_virtual_interface_ids":
			model.AwsDxVirtualInterfaceIds = req.AwsDxVirtualInterfaceIds
		case "aws_ebs_volume_ids":
			model.AwsEbsVolumeIds = req.AwsEbsVolumeIds
		case "aws_ec2_instance_connect_endpoint_ids":
			model.AwsEc2InstanceConnectEndpointIds = req.AwsEc2InstanceConnectEndpointIds
		case "aws_ec2_transit_gateway_attachment_ids":
			model.AwsEc2TransitGatewayAttachmentIds = req.AwsEc2TransitGatewayAttachmentIds
		case "aws_ec2_transit_gateway_ids":
			model.AwsEc2TransitGatewayIds = req.AwsEc2TransitGatewayIds
		case "aws_ec2_transit_gateway_multicast_domain_ids":
			model.AwsEc2TransitGatewayMulticastDomainIds = req.AwsEc2TransitGatewayMulticastDomainIds
		case "aws_ec2_transit_gateway_route_table_ids":
			model.AwsEc2TransitGatewayRouteTableIds = req.AwsEc2TransitGatewayRouteTableIds
		case "aws_egress_only_internet_gateway_ids":
			model.AwsEgressOnlyInternetGatewayIds = req.AwsEgressOnlyInternetGatewayIds
		case "aws_eip_ids":
			model.AwsEipIds = req.AwsEipIds
		case "aws_flow_log_ids":
			model.AwsFlowLogIds = req.AwsFlowLogIds
		case "aws_instances_ids":
			model.AwsInstancesIds = req.AwsInstancesIds
		case "aws_internet_gateway_ids":
			model.AwsInternetGatewayIds = req.AwsInternetGatewayIds
		case "aws_nat_gateway_ids":
			model.AwsNatGatewayIds = req.AwsNatGatewayIds
		case "aws_network_acl_ids":
			model.AwsNetworkAclIds = req.AwsNetworkAclIds
		case "aws_network_interface_ids":
			model.AwsNetworkInterfaceIds = req.AwsNetworkInterfaceIds
		case "aws_rds_cluster_ids":
			model.AwsRdsClusterIds = req.AwsRdsClusterIds
		case "aws_route_table_ids":
			model.AwsRouteTableIds = req.AwsRouteTableIds
		case "aws_security_group_ids":
			model.AwsSecurityGroupIds = req.AwsSecurityGroupIds
		case "aws_security_group_rule_ids":
			model.AwsSecurityGroupRuleIds = req.AwsSecurityGroupRuleIds
		case "aws_spot_fleet_request_ids":
			model.AwsSpotFleetRequestIds = req.AwsSpotFleetRequestIds
		case "aws_spot_instance_request_ids":
			model.AwsSpotInstanceRequestIds = req.AwsSpotInstanceRequestIds
		case "aws_subnet_ids":
			model.AwsSubnetIds = req.AwsSubnetIds
		case "aws_vpc_endpoint_ids":
			model.AwsVpcEndpointIds = req.AwsVpcEndpointIds
		case "aws_vpc_endpoint_service_ids":
			model.AwsVpcEndpointServiceIds = req.AwsVpcEndpointServiceIds
		case "aws_vpc_ids":
			model.AwsVpcIds = req.AwsVpcIds
		case "aws_vpc_peering_connection_ids":
			model.AwsVpcPeeringConnectionIds = req.AwsVpcPeeringConnectionIds
		case "aws_vpn_connection_ids":
			model.AwsVpnConnectionIds = req.AwsVpnConnectionIds
		case "aws_vpn_gateway_ids":
			model.AwsVpnGatewayIds = req.AwsVpnGatewayIds
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "application_aws_resources"),
				zap.String("method", "UpdateApplicationAwsResources"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for application_aws_resources: %s", path)
		}
	}
	resp := &configv1.UpdateApplicationAwsResourcesResponse{
		Id:                                     id,
		AccountId:                              model.AccountId,
		ApplicationId:                          model.ApplicationId,
		ApplicationResourceIds:                 model.ApplicationResourceIds,
		Arns:                                   model.Arns,
		AwsCustomerGatewayIds:                  model.AwsCustomerGatewayIds,
		AwsDxConnectionIds:                     model.AwsDxConnectionIds,
		AwsDxVirtualInterfaceIds:               model.AwsDxVirtualInterfaceIds,
		AwsEbsVolumeIds:                        model.AwsEbsVolumeIds,
		AwsEc2InstanceConnectEndpointIds:       model.AwsEc2InstanceConnectEndpointIds,
		AwsEc2TransitGatewayAttachmentIds:      model.AwsEc2TransitGatewayAttachmentIds,
		AwsEc2TransitGatewayIds:                model.AwsEc2TransitGatewayIds,
		AwsEc2TransitGatewayMulticastDomainIds: model.AwsEc2TransitGatewayMulticastDomainIds,
		AwsEc2TransitGatewayRouteTableIds:      model.AwsEc2TransitGatewayRouteTableIds,
		AwsEgressOnlyInternetGatewayIds:        model.AwsEgressOnlyInternetGatewayIds,
		AwsEipIds:                              model.AwsEipIds,
		AwsFlowLogIds:                          model.AwsFlowLogIds,
		AwsInstancesIds:                        model.AwsInstancesIds,
		AwsInternetGatewayIds:                  model.AwsInternetGatewayIds,
		AwsNatGatewayIds:                       model.AwsNatGatewayIds,
		AwsNetworkAclIds:                       model.AwsNetworkAclIds,
		AwsNetworkInterfaceIds:                 model.AwsNetworkInterfaceIds,
		AwsRdsClusterIds:                       model.AwsRdsClusterIds,
		AwsRouteTableIds:                       model.AwsRouteTableIds,
		AwsSecurityGroupIds:                    model.AwsSecurityGroupIds,
		AwsSecurityGroupRuleIds:                model.AwsSecurityGroupRuleIds,
		AwsSpotFleetRequestIds:                 model.AwsSpotFleetRequestIds,
		AwsSpotInstanceRequestIds:              model.AwsSpotInstanceRequestIds,
		AwsSubnetIds:                           model.AwsSubnetIds,
		AwsVpcEndpointIds:                      model.AwsVpcEndpointIds,
		AwsVpcEndpointServiceIds:               model.AwsVpcEndpointServiceIds,
		AwsVpcIds:                              model.AwsVpcIds,
		AwsVpcPeeringConnectionIds:             model.AwsVpcPeeringConnectionIds,
		AwsVpnConnectionIds:                    model.AwsVpnConnectionIds,
		AwsVpnGatewayIds:                       model.AwsVpnGatewayIds,
	}
	s.ApplicationAwsResourcesMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "application_aws_resources"),
		zap.String("method", "UpdateApplicationAwsResources"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteApplicationAwsResources(ctx context.Context, req *configv1.DeleteApplicationAwsResourcesRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.ApplicationAwsResourcesMutex.Lock()
	_, found := s.ApplicationAwsResourcesMap[id]
	if !found {
		s.ApplicationAwsResourcesMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "application_aws_resources"),
			zap.String("method", "DeleteApplicationAwsResources"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_aws_resources found with id %s", id)
	}
	delete(s.ApplicationAwsResourcesMap, id)
	s.ApplicationAwsResourcesMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "application_aws_resources"),
		zap.String("method", "DeleteApplicationAwsResources"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateApplicationAzureResources(ctx context.Context, req *configv1.CreateApplicationAzureResourcesRequest) (*configv1.CreateApplicationAzureResourcesResponse, error) {
	id := uuid.New().String()
	model := &ApplicationAzureResources{
		Id:             id,
		ApplicationId:  req.ApplicationId,
		ResourceIds:    req.ResourceIds,
		SubscriptionId: req.SubscriptionId,
	}
	resp := &configv1.CreateApplicationAzureResourcesResponse{
		Id:                     id,
		ApplicationId:          model.ApplicationId,
		ApplicationResourceIds: model.ApplicationResourceIds,
		ResourceIds:            model.ResourceIds,
		SubscriptionId:         model.SubscriptionId,
	}
	s.ApplicationAzureResourcesMutex.Lock()
	s.ApplicationAzureResourcesMap[id] = model
	s.ApplicationAzureResourcesMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "application_azure_resources"),
		zap.String("method", "CreateApplicationAzureResources"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadApplicationAzureResources(ctx context.Context, req *configv1.ReadApplicationAzureResourcesRequest) (*configv1.ReadApplicationAzureResourcesResponse, error) {
	id := req.Id
	s.ApplicationAzureResourcesMutex.RLock()
	model, found := s.ApplicationAzureResourcesMap[id]
	if !found {
		s.ApplicationAzureResourcesMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "application_azure_resources"),
			zap.String("method", "ReadApplicationAzureResources"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_azure_resources found with id %s", id)
	}
	resp := &configv1.ReadApplicationAzureResourcesResponse{
		Id:                     id,
		ApplicationId:          model.ApplicationId,
		ApplicationResourceIds: model.ApplicationResourceIds,
		ResourceIds:            model.ResourceIds,
		SubscriptionId:         model.SubscriptionId,
	}
	s.ApplicationAzureResourcesMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "application_azure_resources"),
		zap.String("method", "ReadApplicationAzureResources"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateApplicationAzureResources(ctx context.Context, req *configv1.UpdateApplicationAzureResourcesRequest) (*configv1.UpdateApplicationAzureResourcesResponse, error) {
	id := req.Id
	s.ApplicationAzureResourcesMutex.Lock()
	model, found := s.ApplicationAzureResourcesMap[id]
	if !found {
		s.ApplicationAzureResourcesMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "application_azure_resources"),
			zap.String("method", "UpdateApplicationAzureResources"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_azure_resources found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "application_id":
			model.ApplicationId = req.ApplicationId
		case "application_resource_ids":
			model.ApplicationResourceIds = req.ApplicationResourceIds
		case "resource_ids":
			model.ResourceIds = req.ResourceIds
		case "subscription_id":
			model.SubscriptionId = req.SubscriptionId
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "application_azure_resources"),
				zap.String("method", "UpdateApplicationAzureResources"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for application_azure_resources: %s", path)
		}
	}
	resp := &configv1.UpdateApplicationAzureResourcesResponse{
		Id:                     id,
		ApplicationId:          model.ApplicationId,
		ApplicationResourceIds: model.ApplicationResourceIds,
		ResourceIds:            model.ResourceIds,
		SubscriptionId:         model.SubscriptionId,
	}
	s.ApplicationAzureResourcesMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "application_azure_resources"),
		zap.String("method", "UpdateApplicationAzureResources"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteApplicationAzureResources(ctx context.Context, req *configv1.DeleteApplicationAzureResourcesRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.ApplicationAzureResourcesMutex.Lock()
	_, found := s.ApplicationAzureResourcesMap[id]
	if !found {
		s.ApplicationAzureResourcesMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "application_azure_resources"),
			zap.String("method", "DeleteApplicationAzureResources"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_azure_resources found with id %s", id)
	}
	delete(s.ApplicationAzureResourcesMap, id)
	s.ApplicationAzureResourcesMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "application_azure_resources"),
		zap.String("method", "DeleteApplicationAzureResources"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateApplicationPolicyRule(ctx context.Context, req *configv1.CreateApplicationPolicyRuleRequest) (*configv1.CreateApplicationPolicyRuleResponse, error) {
	id := uuid.New().String()
	model := &ApplicationPolicyRule{
		Id:            id,
		Action:        req.Action,
		ApplicationId: req.ApplicationId,
		Description:   req.Description,
		ExternalScope: req.ExternalScope,
		FromIpListIds: req.FromIpListIds,
		FromLabels:    req.FromLabels,
		ToIpListIds:   req.ToIpListIds,
		ToLabels:      req.ToLabels,
		ToPortRanges:  req.ToPortRanges,
	}
	resp := &configv1.CreateApplicationPolicyRuleResponse{
		Id:            id,
		Action:        model.Action,
		ApplicationId: model.ApplicationId,
		Description:   model.Description,
		ExternalScope: model.ExternalScope,
		FromIpListIds: model.FromIpListIds,
		FromLabels:    model.FromLabels,
		ToIpListIds:   model.ToIpListIds,
		ToLabels:      model.ToLabels,
		ToPortRanges:  model.ToPortRanges,
	}
	s.ApplicationPolicyRuleMutex.Lock()
	s.ApplicationPolicyRuleMap[id] = model
	s.ApplicationPolicyRuleMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "application_policy_rule"),
		zap.String("method", "CreateApplicationPolicyRule"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadApplicationPolicyRule(ctx context.Context, req *configv1.ReadApplicationPolicyRuleRequest) (*configv1.ReadApplicationPolicyRuleResponse, error) {
	id := req.Id
	s.ApplicationPolicyRuleMutex.RLock()
	model, found := s.ApplicationPolicyRuleMap[id]
	if !found {
		s.ApplicationPolicyRuleMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "application_policy_rule"),
			zap.String("method", "ReadApplicationPolicyRule"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_policy_rule found with id %s", id)
	}
	resp := &configv1.ReadApplicationPolicyRuleResponse{
		Id:            id,
		Action:        model.Action,
		ApplicationId: model.ApplicationId,
		Description:   model.Description,
		ExternalScope: model.ExternalScope,
		FromIpListIds: model.FromIpListIds,
		FromLabels:    model.FromLabels,
		ToIpListIds:   model.ToIpListIds,
		ToLabels:      model.ToLabels,
		ToPortRanges:  model.ToPortRanges,
	}
	s.ApplicationPolicyRuleMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "application_policy_rule"),
		zap.String("method", "ReadApplicationPolicyRule"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateApplicationPolicyRule(ctx context.Context, req *configv1.UpdateApplicationPolicyRuleRequest) (*configv1.UpdateApplicationPolicyRuleResponse, error) {
	id := req.Id
	s.ApplicationPolicyRuleMutex.Lock()
	model, found := s.ApplicationPolicyRuleMap[id]
	if !found {
		s.ApplicationPolicyRuleMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "application_policy_rule"),
			zap.String("method", "UpdateApplicationPolicyRule"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_policy_rule found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "action":
			model.Action = req.Action
		case "application_id":
			model.ApplicationId = req.ApplicationId
		case "description":
			model.Description = req.Description
		case "external_scope":
			model.ExternalScope = req.ExternalScope
		case "from_ip_list_ids":
			model.FromIpListIds = req.FromIpListIds
		case "from_labels":
			model.FromLabels = req.FromLabels
		case "to_ip_list_ids":
			model.ToIpListIds = req.ToIpListIds
		case "to_labels":
			model.ToLabels = req.ToLabels
		case "to_port_ranges":
			model.ToPortRanges = req.ToPortRanges
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "application_policy_rule"),
				zap.String("method", "UpdateApplicationPolicyRule"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for application_policy_rule: %s", path)
		}
	}
	resp := &configv1.UpdateApplicationPolicyRuleResponse{
		Id:            id,
		Action:        model.Action,
		ApplicationId: model.ApplicationId,
		Description:   model.Description,
		ExternalScope: model.ExternalScope,
		FromIpListIds: model.FromIpListIds,
		FromLabels:    model.FromLabels,
		ToIpListIds:   model.ToIpListIds,
		ToLabels:      model.ToLabels,
		ToPortRanges:  model.ToPortRanges,
	}
	s.ApplicationPolicyRuleMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "application_policy_rule"),
		zap.String("method", "UpdateApplicationPolicyRule"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteApplicationPolicyRule(ctx context.Context, req *configv1.DeleteApplicationPolicyRuleRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.ApplicationPolicyRuleMutex.Lock()
	_, found := s.ApplicationPolicyRuleMap[id]
	if !found {
		s.ApplicationPolicyRuleMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "application_policy_rule"),
			zap.String("method", "DeleteApplicationPolicyRule"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no application_policy_rule found with id %s", id)
	}
	delete(s.ApplicationPolicyRuleMap, id)
	s.ApplicationPolicyRuleMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "application_policy_rule"),
		zap.String("method", "DeleteApplicationPolicyRule"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateAwsAccount(ctx context.Context, req *configv1.CreateAwsAccountRequest) (*configv1.CreateAwsAccountResponse, error) {
	id := uuid.New().String()
	model := &AwsAccount{
		Id:             id,
		AccountId:      req.AccountId,
		Mode:           req.Mode,
		Name:           req.Name,
		OrganizationId: req.OrganizationId,
		RoleArn:        req.RoleArn,
		RoleExternalId: req.RoleExternalId,
	}
	resp := &configv1.CreateAwsAccountResponse{
		Id:             id,
		AccountId:      model.AccountId,
		Mode:           model.Mode,
		Name:           model.Name,
		OrganizationId: model.OrganizationId,
		RoleArn:        model.RoleArn,
	}
	s.AwsAccountMutex.Lock()
	s.AwsAccountMap[id] = model
	s.AwsAccountMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "aws_account"),
		zap.String("method", "CreateAwsAccount"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadAwsAccount(ctx context.Context, req *configv1.ReadAwsAccountRequest) (*configv1.ReadAwsAccountResponse, error) {
	id := req.Id
	s.AwsAccountMutex.RLock()
	model, found := s.AwsAccountMap[id]
	if !found {
		s.AwsAccountMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "aws_account"),
			zap.String("method", "ReadAwsAccount"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no aws_account found with id %s", id)
	}
	resp := &configv1.ReadAwsAccountResponse{
		Id:             id,
		AccountId:      model.AccountId,
		Mode:           model.Mode,
		Name:           model.Name,
		OrganizationId: model.OrganizationId,
		RoleArn:        model.RoleArn,
	}
	s.AwsAccountMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "aws_account"),
		zap.String("method", "ReadAwsAccount"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateAwsAccount(ctx context.Context, req *configv1.UpdateAwsAccountRequest) (*configv1.UpdateAwsAccountResponse, error) {
	id := req.Id
	s.AwsAccountMutex.Lock()
	model, found := s.AwsAccountMap[id]
	if !found {
		s.AwsAccountMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "aws_account"),
			zap.String("method", "UpdateAwsAccount"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no aws_account found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "aws_account"),
				zap.String("method", "UpdateAwsAccount"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for aws_account: %s", path)
		}
	}
	resp := &configv1.UpdateAwsAccountResponse{
		Id:             id,
		AccountId:      model.AccountId,
		Mode:           model.Mode,
		Name:           model.Name,
		OrganizationId: model.OrganizationId,
		RoleArn:        model.RoleArn,
	}
	s.AwsAccountMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "aws_account"),
		zap.String("method", "UpdateAwsAccount"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteAwsAccount(ctx context.Context, req *configv1.DeleteAwsAccountRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.AwsAccountMutex.Lock()
	_, found := s.AwsAccountMap[id]
	if !found {
		s.AwsAccountMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "aws_account"),
			zap.String("method", "DeleteAwsAccount"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no aws_account found with id %s", id)
	}
	delete(s.AwsAccountMap, id)
	s.AwsAccountMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "aws_account"),
		zap.String("method", "DeleteAwsAccount"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateAwsFlowLogsS3Bucket(ctx context.Context, req *configv1.CreateAwsFlowLogsS3BucketRequest) (*configv1.CreateAwsFlowLogsS3BucketResponse, error) {
	id := uuid.New().String()
	model := &AwsFlowLogsS3Bucket{
		Id:          id,
		AccountId:   req.AccountId,
		S3BucketArn: req.S3BucketArn,
	}
	resp := &configv1.CreateAwsFlowLogsS3BucketResponse{
		Id:          id,
		AccountId:   model.AccountId,
		S3BucketArn: model.S3BucketArn,
	}
	s.AwsFlowLogsS3BucketMutex.Lock()
	s.AwsFlowLogsS3BucketMap[id] = model
	s.AwsFlowLogsS3BucketMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "aws_flow_logs_s3_bucket"),
		zap.String("method", "CreateAwsFlowLogsS3Bucket"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadAwsFlowLogsS3Bucket(ctx context.Context, req *configv1.ReadAwsFlowLogsS3BucketRequest) (*configv1.ReadAwsFlowLogsS3BucketResponse, error) {
	id := req.Id
	s.AwsFlowLogsS3BucketMutex.RLock()
	model, found := s.AwsFlowLogsS3BucketMap[id]
	if !found {
		s.AwsFlowLogsS3BucketMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "aws_flow_logs_s3_bucket"),
			zap.String("method", "ReadAwsFlowLogsS3Bucket"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no aws_flow_logs_s3_bucket found with id %s", id)
	}
	resp := &configv1.ReadAwsFlowLogsS3BucketResponse{
		Id:          id,
		AccountId:   model.AccountId,
		S3BucketArn: model.S3BucketArn,
	}
	s.AwsFlowLogsS3BucketMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "aws_flow_logs_s3_bucket"),
		zap.String("method", "ReadAwsFlowLogsS3Bucket"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateAwsFlowLogsS3Bucket(ctx context.Context, req *configv1.UpdateAwsFlowLogsS3BucketRequest) (*configv1.UpdateAwsFlowLogsS3BucketResponse, error) {
	id := req.Id
	s.AwsFlowLogsS3BucketMutex.Lock()
	model, found := s.AwsFlowLogsS3BucketMap[id]
	if !found {
		s.AwsFlowLogsS3BucketMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "aws_flow_logs_s3_bucket"),
			zap.String("method", "UpdateAwsFlowLogsS3Bucket"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no aws_flow_logs_s3_bucket found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "aws_flow_logs_s3_bucket"),
				zap.String("method", "UpdateAwsFlowLogsS3Bucket"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for aws_flow_logs_s3_bucket: %s", path)
		}
	}
	resp := &configv1.UpdateAwsFlowLogsS3BucketResponse{
		Id:          id,
		AccountId:   model.AccountId,
		S3BucketArn: model.S3BucketArn,
	}
	s.AwsFlowLogsS3BucketMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "aws_flow_logs_s3_bucket"),
		zap.String("method", "UpdateAwsFlowLogsS3Bucket"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteAwsFlowLogsS3Bucket(ctx context.Context, req *configv1.DeleteAwsFlowLogsS3BucketRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.AwsFlowLogsS3BucketMutex.Lock()
	_, found := s.AwsFlowLogsS3BucketMap[id]
	if !found {
		s.AwsFlowLogsS3BucketMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "aws_flow_logs_s3_bucket"),
			zap.String("method", "DeleteAwsFlowLogsS3Bucket"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no aws_flow_logs_s3_bucket found with id %s", id)
	}
	delete(s.AwsFlowLogsS3BucketMap, id)
	s.AwsFlowLogsS3BucketMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "aws_flow_logs_s3_bucket"),
		zap.String("method", "DeleteAwsFlowLogsS3Bucket"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateAzureFlowLogsStorageAccount(ctx context.Context, req *configv1.CreateAzureFlowLogsStorageAccountRequest) (*configv1.CreateAzureFlowLogsStorageAccountResponse, error) {
	id := uuid.New().String()
	model := &AzureFlowLogsStorageAccount{
		Id:                       id,
		StorageAccountResourceId: req.StorageAccountResourceId,
		SubscriptionId:           req.SubscriptionId,
	}
	resp := &configv1.CreateAzureFlowLogsStorageAccountResponse{
		Id:                       id,
		StorageAccountResourceId: model.StorageAccountResourceId,
		SubscriptionId:           model.SubscriptionId,
	}
	s.AzureFlowLogsStorageAccountMutex.Lock()
	s.AzureFlowLogsStorageAccountMap[id] = model
	s.AzureFlowLogsStorageAccountMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "azure_flow_logs_storage_account"),
		zap.String("method", "CreateAzureFlowLogsStorageAccount"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadAzureFlowLogsStorageAccount(ctx context.Context, req *configv1.ReadAzureFlowLogsStorageAccountRequest) (*configv1.ReadAzureFlowLogsStorageAccountResponse, error) {
	id := req.Id
	s.AzureFlowLogsStorageAccountMutex.RLock()
	model, found := s.AzureFlowLogsStorageAccountMap[id]
	if !found {
		s.AzureFlowLogsStorageAccountMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "azure_flow_logs_storage_account"),
			zap.String("method", "ReadAzureFlowLogsStorageAccount"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no azure_flow_logs_storage_account found with id %s", id)
	}
	resp := &configv1.ReadAzureFlowLogsStorageAccountResponse{
		Id:                       id,
		StorageAccountResourceId: model.StorageAccountResourceId,
		SubscriptionId:           model.SubscriptionId,
	}
	s.AzureFlowLogsStorageAccountMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "azure_flow_logs_storage_account"),
		zap.String("method", "ReadAzureFlowLogsStorageAccount"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateAzureFlowLogsStorageAccount(ctx context.Context, req *configv1.UpdateAzureFlowLogsStorageAccountRequest) (*configv1.UpdateAzureFlowLogsStorageAccountResponse, error) {
	id := req.Id
	s.AzureFlowLogsStorageAccountMutex.Lock()
	model, found := s.AzureFlowLogsStorageAccountMap[id]
	if !found {
		s.AzureFlowLogsStorageAccountMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "azure_flow_logs_storage_account"),
			zap.String("method", "UpdateAzureFlowLogsStorageAccount"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no azure_flow_logs_storage_account found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "azure_flow_logs_storage_account"),
				zap.String("method", "UpdateAzureFlowLogsStorageAccount"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for azure_flow_logs_storage_account: %s", path)
		}
	}
	resp := &configv1.UpdateAzureFlowLogsStorageAccountResponse{
		Id:                       id,
		StorageAccountResourceId: model.StorageAccountResourceId,
		SubscriptionId:           model.SubscriptionId,
	}
	s.AzureFlowLogsStorageAccountMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "azure_flow_logs_storage_account"),
		zap.String("method", "UpdateAzureFlowLogsStorageAccount"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteAzureFlowLogsStorageAccount(ctx context.Context, req *configv1.DeleteAzureFlowLogsStorageAccountRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.AzureFlowLogsStorageAccountMutex.Lock()
	_, found := s.AzureFlowLogsStorageAccountMap[id]
	if !found {
		s.AzureFlowLogsStorageAccountMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "azure_flow_logs_storage_account"),
			zap.String("method", "DeleteAzureFlowLogsStorageAccount"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no azure_flow_logs_storage_account found with id %s", id)
	}
	delete(s.AzureFlowLogsStorageAccountMap, id)
	s.AzureFlowLogsStorageAccountMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "azure_flow_logs_storage_account"),
		zap.String("method", "DeleteAzureFlowLogsStorageAccount"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateAzureSubscription(ctx context.Context, req *configv1.CreateAzureSubscriptionRequest) (*configv1.CreateAzureSubscriptionResponse, error) {
	id := uuid.New().String()
	model := &AzureSubscription{
		Id:             id,
		ClientId:       req.ClientId,
		ClientSecret:   req.ClientSecret,
		Mode:           req.Mode,
		Name:           req.Name,
		SubscriptionId: req.SubscriptionId,
		TenantId:       req.TenantId,
	}
	resp := &configv1.CreateAzureSubscriptionResponse{
		Id:             id,
		ClientId:       model.ClientId,
		Mode:           model.Mode,
		Name:           model.Name,
		SubscriptionId: model.SubscriptionId,
		TenantId:       model.TenantId,
	}
	s.AzureSubscriptionMutex.Lock()
	s.AzureSubscriptionMap[id] = model
	s.AzureSubscriptionMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "azure_subscription"),
		zap.String("method", "CreateAzureSubscription"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadAzureSubscription(ctx context.Context, req *configv1.ReadAzureSubscriptionRequest) (*configv1.ReadAzureSubscriptionResponse, error) {
	id := req.Id
	s.AzureSubscriptionMutex.RLock()
	model, found := s.AzureSubscriptionMap[id]
	if !found {
		s.AzureSubscriptionMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "azure_subscription"),
			zap.String("method", "ReadAzureSubscription"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no azure_subscription found with id %s", id)
	}
	resp := &configv1.ReadAzureSubscriptionResponse{
		Id:             id,
		ClientId:       model.ClientId,
		Mode:           model.Mode,
		Name:           model.Name,
		SubscriptionId: model.SubscriptionId,
		TenantId:       model.TenantId,
	}
	s.AzureSubscriptionMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "azure_subscription"),
		zap.String("method", "ReadAzureSubscription"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateAzureSubscription(ctx context.Context, req *configv1.UpdateAzureSubscriptionRequest) (*configv1.UpdateAzureSubscriptionResponse, error) {
	id := req.Id
	s.AzureSubscriptionMutex.Lock()
	model, found := s.AzureSubscriptionMap[id]
	if !found {
		s.AzureSubscriptionMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "azure_subscription"),
			zap.String("method", "UpdateAzureSubscription"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no azure_subscription found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "azure_subscription"),
				zap.String("method", "UpdateAzureSubscription"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for azure_subscription: %s", path)
		}
	}
	resp := &configv1.UpdateAzureSubscriptionResponse{
		Id:             id,
		ClientId:       model.ClientId,
		Mode:           model.Mode,
		Name:           model.Name,
		SubscriptionId: model.SubscriptionId,
		TenantId:       model.TenantId,
	}
	s.AzureSubscriptionMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "azure_subscription"),
		zap.String("method", "UpdateAzureSubscription"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteAzureSubscription(ctx context.Context, req *configv1.DeleteAzureSubscriptionRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.AzureSubscriptionMutex.Lock()
	_, found := s.AzureSubscriptionMap[id]
	if !found {
		s.AzureSubscriptionMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "azure_subscription"),
			zap.String("method", "DeleteAzureSubscription"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no azure_subscription found with id %s", id)
	}
	delete(s.AzureSubscriptionMap, id)
	s.AzureSubscriptionMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "azure_subscription"),
		zap.String("method", "DeleteAzureSubscription"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateDeployment(ctx context.Context, req *configv1.CreateDeploymentRequest) (*configv1.CreateDeploymentResponse, error) {
	id := uuid.New().String()
	model := &Deployment{
		Id:                   id,
		AwsAccountIds:        req.AwsAccountIds,
		AwsRegions:           req.AwsRegions,
		AwsSubnetIds:         req.AwsSubnetIds,
		AwsTags:              req.AwsTags,
		AwsVpcIds:            req.AwsVpcIds,
		AzureRegions:         req.AzureRegions,
		AzureSubnetIds:       req.AzureSubnetIds,
		AzureSubscriptionIds: req.AzureSubscriptionIds,
		AzureTags:            req.AzureTags,
		AzureVnetIds:         req.AzureVnetIds,
		Description:          req.Description,
		Name:                 req.Name,
	}
	resp := &configv1.CreateDeploymentResponse{
		Id:                   id,
		AwsAccountIds:        model.AwsAccountIds,
		AwsRegions:           model.AwsRegions,
		AwsSubnetIds:         model.AwsSubnetIds,
		AwsTags:              model.AwsTags,
		AwsVpcIds:            model.AwsVpcIds,
		AzureRegions:         model.AzureRegions,
		AzureSubnetIds:       model.AzureSubnetIds,
		AzureSubscriptionIds: model.AzureSubscriptionIds,
		AzureTags:            model.AzureTags,
		AzureVnetIds:         model.AzureVnetIds,
		Description:          model.Description,
		Name:                 model.Name,
	}
	s.DeploymentMutex.Lock()
	s.DeploymentMap[id] = model
	s.DeploymentMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "deployment"),
		zap.String("method", "CreateDeployment"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadDeployment(ctx context.Context, req *configv1.ReadDeploymentRequest) (*configv1.ReadDeploymentResponse, error) {
	id := req.Id
	s.DeploymentMutex.RLock()
	model, found := s.DeploymentMap[id]
	if !found {
		s.DeploymentMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "deployment"),
			zap.String("method", "ReadDeployment"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no deployment found with id %s", id)
	}
	resp := &configv1.ReadDeploymentResponse{
		Id:                   id,
		AwsAccountIds:        model.AwsAccountIds,
		AwsRegions:           model.AwsRegions,
		AwsSubnetIds:         model.AwsSubnetIds,
		AwsTags:              model.AwsTags,
		AwsVpcIds:            model.AwsVpcIds,
		AzureRegions:         model.AzureRegions,
		AzureSubnetIds:       model.AzureSubnetIds,
		AzureSubscriptionIds: model.AzureSubscriptionIds,
		AzureTags:            model.AzureTags,
		AzureVnetIds:         model.AzureVnetIds,
		Description:          model.Description,
		Name:                 model.Name,
	}
	s.DeploymentMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "deployment"),
		zap.String("method", "ReadDeployment"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateDeployment(ctx context.Context, req *configv1.UpdateDeploymentRequest) (*configv1.UpdateDeploymentResponse, error) {
	id := req.Id
	s.DeploymentMutex.Lock()
	model, found := s.DeploymentMap[id]
	if !found {
		s.DeploymentMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "deployment"),
			zap.String("method", "UpdateDeployment"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no deployment found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "aws_account_ids":
			model.AwsAccountIds = req.AwsAccountIds
		case "aws_regions":
			model.AwsRegions = req.AwsRegions
		case "aws_subnet_ids":
			model.AwsSubnetIds = req.AwsSubnetIds
		case "aws_tags":
			model.AwsTags = req.AwsTags
		case "aws_vpc_ids":
			model.AwsVpcIds = req.AwsVpcIds
		case "azure_regions":
			model.AzureRegions = req.AzureRegions
		case "azure_subnet_ids":
			model.AzureSubnetIds = req.AzureSubnetIds
		case "azure_subscription_ids":
			model.AzureSubscriptionIds = req.AzureSubscriptionIds
		case "azure_tags":
			model.AzureTags = req.AzureTags
		case "azure_vnet_ids":
			model.AzureVnetIds = req.AzureVnetIds
		case "description":
			model.Description = req.Description
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "deployment"),
				zap.String("method", "UpdateDeployment"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for deployment: %s", path)
		}
	}
	resp := &configv1.UpdateDeploymentResponse{
		Id:                   id,
		AwsAccountIds:        model.AwsAccountIds,
		AwsRegions:           model.AwsRegions,
		AwsSubnetIds:         model.AwsSubnetIds,
		AwsTags:              model.AwsTags,
		AwsVpcIds:            model.AwsVpcIds,
		AzureRegions:         model.AzureRegions,
		AzureSubnetIds:       model.AzureSubnetIds,
		AzureSubscriptionIds: model.AzureSubscriptionIds,
		AzureTags:            model.AzureTags,
		AzureVnetIds:         model.AzureVnetIds,
		Description:          model.Description,
		Name:                 model.Name,
	}
	s.DeploymentMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "deployment"),
		zap.String("method", "UpdateDeployment"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteDeployment(ctx context.Context, req *configv1.DeleteDeploymentRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.DeploymentMutex.Lock()
	_, found := s.DeploymentMap[id]
	if !found {
		s.DeploymentMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "deployment"),
			zap.String("method", "DeleteDeployment"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no deployment found with id %s", id)
	}
	delete(s.DeploymentMap, id)
	s.DeploymentMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "deployment"),
		zap.String("method", "DeleteDeployment"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateIpList(ctx context.Context, req *configv1.CreateIpListRequest) (*configv1.CreateIpListResponse, error) {
	id := uuid.New().String()
	model := &IpList{
		Id:          id,
		Description: req.Description,
		IpAddresses: req.IpAddresses,
		IpRanges:    req.IpRanges,
		Name:        req.Name,
	}
	resp := &configv1.CreateIpListResponse{
		Id:          id,
		Description: model.Description,
		IpAddresses: model.IpAddresses,
		IpRanges:    model.IpRanges,
		Name:        model.Name,
	}
	s.IpListMutex.Lock()
	s.IpListMap[id] = model
	s.IpListMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "ip_list"),
		zap.String("method", "CreateIpList"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadIpList(ctx context.Context, req *configv1.ReadIpListRequest) (*configv1.ReadIpListResponse, error) {
	id := req.Id
	s.IpListMutex.RLock()
	model, found := s.IpListMap[id]
	if !found {
		s.IpListMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "ip_list"),
			zap.String("method", "ReadIpList"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no ip_list found with id %s", id)
	}
	resp := &configv1.ReadIpListResponse{
		Id:          id,
		Description: model.Description,
		IpAddresses: model.IpAddresses,
		IpRanges:    model.IpRanges,
		Name:        model.Name,
	}
	s.IpListMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "ip_list"),
		zap.String("method", "ReadIpList"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateIpList(ctx context.Context, req *configv1.UpdateIpListRequest) (*configv1.UpdateIpListResponse, error) {
	id := req.Id
	s.IpListMutex.Lock()
	model, found := s.IpListMap[id]
	if !found {
		s.IpListMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "ip_list"),
			zap.String("method", "UpdateIpList"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no ip_list found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "description":
			model.Description = req.Description
		case "ip_addresses":
			model.IpAddresses = req.IpAddresses
		case "ip_ranges":
			model.IpRanges = req.IpRanges
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "ip_list"),
				zap.String("method", "UpdateIpList"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for ip_list: %s", path)
		}
	}
	resp := &configv1.UpdateIpListResponse{
		Id:          id,
		Description: model.Description,
		IpAddresses: model.IpAddresses,
		IpRanges:    model.IpRanges,
		Name:        model.Name,
	}
	s.IpListMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "ip_list"),
		zap.String("method", "UpdateIpList"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteIpList(ctx context.Context, req *configv1.DeleteIpListRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.IpListMutex.Lock()
	_, found := s.IpListMap[id]
	if !found {
		s.IpListMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "ip_list"),
			zap.String("method", "DeleteIpList"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no ip_list found with id %s", id)
	}
	delete(s.IpListMap, id)
	s.IpListMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "ip_list"),
		zap.String("method", "DeleteIpList"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateK8SCluster(ctx context.Context, req *configv1.CreateK8SClusterRequest) (*configv1.CreateK8SClusterResponse, error) {
	id := uuid.New().String()
	model := &K8SCluster{
		Id:            id,
		IllumioRegion: req.IllumioRegion,
	}
	resp := &configv1.CreateK8SClusterResponse{
		Id:            id,
		ClientId:      model.ClientId,
		ClientSecret:  model.ClientSecret,
		IllumioRegion: model.IllumioRegion,
	}
	s.K8SClusterMutex.Lock()
	s.K8SClusterMap[id] = model
	s.K8SClusterMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "k8s_cluster"),
		zap.String("method", "CreateK8SCluster"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadK8SCluster(ctx context.Context, req *configv1.ReadK8SClusterRequest) (*configv1.ReadK8SClusterResponse, error) {
	id := req.Id
	s.K8SClusterMutex.RLock()
	model, found := s.K8SClusterMap[id]
	if !found {
		s.K8SClusterMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "k8s_cluster"),
			zap.String("method", "ReadK8SCluster"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no k8s_cluster found with id %s", id)
	}
	resp := &configv1.ReadK8SClusterResponse{
		Id:            id,
		ClientId:      model.ClientId,
		IllumioRegion: model.IllumioRegion,
	}
	s.K8SClusterMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "k8s_cluster"),
		zap.String("method", "ReadK8SCluster"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateK8SCluster(ctx context.Context, req *configv1.UpdateK8SClusterRequest) (*configv1.UpdateK8SClusterResponse, error) {
	id := req.Id
	s.K8SClusterMutex.Lock()
	model, found := s.K8SClusterMap[id]
	if !found {
		s.K8SClusterMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "k8s_cluster"),
			zap.String("method", "UpdateK8SCluster"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no k8s_cluster found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "k8s_cluster"),
				zap.String("method", "UpdateK8SCluster"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for k8s_cluster: %s", path)
		}
	}
	resp := &configv1.UpdateK8SClusterResponse{
		Id:            id,
		ClientId:      model.ClientId,
		IllumioRegion: model.IllumioRegion,
	}
	s.K8SClusterMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "k8s_cluster"),
		zap.String("method", "UpdateK8SCluster"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteK8SCluster(ctx context.Context, req *configv1.DeleteK8SClusterRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.K8SClusterMutex.Lock()
	_, found := s.K8SClusterMap[id]
	if !found {
		s.K8SClusterMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "k8s_cluster"),
			zap.String("method", "DeleteK8SCluster"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no k8s_cluster found with id %s", id)
	}
	delete(s.K8SClusterMap, id)
	s.K8SClusterMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "k8s_cluster"),
		zap.String("method", "DeleteK8SCluster"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateK8SClusterOnboardingCredential(ctx context.Context, req *configv1.CreateK8SClusterOnboardingCredentialRequest) (*configv1.CreateK8SClusterOnboardingCredentialResponse, error) {
	id := uuid.New().String()
	model := &K8SClusterOnboardingCredential{
		Id:            id,
		Description:   req.Description,
		IllumioRegion: req.IllumioRegion,
		Name:          req.Name,
	}
	resp := &configv1.CreateK8SClusterOnboardingCredentialResponse{
		Id:            id,
		ClientId:      model.ClientId,
		ClientSecret:  model.ClientSecret,
		CreatedAt:     model.CreatedAt,
		Description:   model.Description,
		IllumioRegion: model.IllumioRegion,
		Name:          model.Name,
	}
	s.K8SClusterOnboardingCredentialMutex.Lock()
	s.K8SClusterOnboardingCredentialMap[id] = model
	s.K8SClusterOnboardingCredentialMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "k8s_cluster_onboarding_credential"),
		zap.String("method", "CreateK8SClusterOnboardingCredential"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadK8SClusterOnboardingCredential(ctx context.Context, req *configv1.ReadK8SClusterOnboardingCredentialRequest) (*configv1.ReadK8SClusterOnboardingCredentialResponse, error) {
	id := req.Id
	s.K8SClusterOnboardingCredentialMutex.RLock()
	model, found := s.K8SClusterOnboardingCredentialMap[id]
	if !found {
		s.K8SClusterOnboardingCredentialMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "k8s_cluster_onboarding_credential"),
			zap.String("method", "ReadK8SClusterOnboardingCredential"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no k8s_cluster_onboarding_credential found with id %s", id)
	}
	resp := &configv1.ReadK8SClusterOnboardingCredentialResponse{
		Id:            id,
		ClientId:      model.ClientId,
		CreatedAt:     model.CreatedAt,
		Description:   model.Description,
		IllumioRegion: model.IllumioRegion,
		Name:          model.Name,
	}
	s.K8SClusterOnboardingCredentialMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "k8s_cluster_onboarding_credential"),
		zap.String("method", "ReadK8SClusterOnboardingCredential"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateK8SClusterOnboardingCredential(ctx context.Context, req *configv1.UpdateK8SClusterOnboardingCredentialRequest) (*configv1.UpdateK8SClusterOnboardingCredentialResponse, error) {
	id := req.Id
	s.K8SClusterOnboardingCredentialMutex.Lock()
	model, found := s.K8SClusterOnboardingCredentialMap[id]
	if !found {
		s.K8SClusterOnboardingCredentialMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "k8s_cluster_onboarding_credential"),
			zap.String("method", "UpdateK8SClusterOnboardingCredential"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no k8s_cluster_onboarding_credential found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "description":
			model.Description = req.Description
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "k8s_cluster_onboarding_credential"),
				zap.String("method", "UpdateK8SClusterOnboardingCredential"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for k8s_cluster_onboarding_credential: %s", path)
		}
	}
	resp := &configv1.UpdateK8SClusterOnboardingCredentialResponse{
		Id:            id,
		ClientId:      model.ClientId,
		CreatedAt:     model.CreatedAt,
		Description:   model.Description,
		IllumioRegion: model.IllumioRegion,
		Name:          model.Name,
	}
	s.K8SClusterOnboardingCredentialMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "k8s_cluster_onboarding_credential"),
		zap.String("method", "UpdateK8SClusterOnboardingCredential"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteK8SClusterOnboardingCredential(ctx context.Context, req *configv1.DeleteK8SClusterOnboardingCredentialRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.K8SClusterOnboardingCredentialMutex.Lock()
	_, found := s.K8SClusterOnboardingCredentialMap[id]
	if !found {
		s.K8SClusterOnboardingCredentialMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "k8s_cluster_onboarding_credential"),
			zap.String("method", "DeleteK8SClusterOnboardingCredential"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no k8s_cluster_onboarding_credential found with id %s", id)
	}
	delete(s.K8SClusterOnboardingCredentialMap, id)
	s.K8SClusterOnboardingCredentialMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "k8s_cluster_onboarding_credential"),
		zap.String("method", "DeleteK8SClusterOnboardingCredential"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
func (s *FakeConfigServer) CreateTagToLabel(ctx context.Context, req *configv1.CreateTagToLabelRequest) (*configv1.CreateTagToLabelResponse, error) {
	id := uuid.New().String()
	model := &TagToLabel{
		Id:           id,
		AwsTagKeys:   req.AwsTagKeys,
		AzureTagKeys: req.AzureTagKeys,
		Icon:         req.Icon,
		Key:          req.Key,
		Name:         req.Name,
	}
	resp := &configv1.CreateTagToLabelResponse{
		Id:           id,
		AwsTagKeys:   model.AwsTagKeys,
		AzureTagKeys: model.AzureTagKeys,
		Icon:         model.Icon,
		Key:          model.Key,
		Name:         model.Name,
	}
	s.TagToLabelMutex.Lock()
	s.TagToLabelMap[id] = model
	s.TagToLabelMutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "tag_to_label"),
		zap.String("method", "CreateTagToLabel"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) ReadTagToLabel(ctx context.Context, req *configv1.ReadTagToLabelRequest) (*configv1.ReadTagToLabelResponse, error) {
	id := req.Id
	s.TagToLabelMutex.RLock()
	model, found := s.TagToLabelMap[id]
	if !found {
		s.TagToLabelMutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "tag_to_label"),
			zap.String("method", "ReadTagToLabel"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no tag_to_label found with id %s", id)
	}
	resp := &configv1.ReadTagToLabelResponse{
		Id:           id,
		AwsTagKeys:   model.AwsTagKeys,
		AzureTagKeys: model.AzureTagKeys,
		Icon:         model.Icon,
		Key:          model.Key,
		Name:         model.Name,
	}
	s.TagToLabelMutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "tag_to_label"),
		zap.String("method", "ReadTagToLabel"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *FakeConfigServer) UpdateTagToLabel(ctx context.Context, req *configv1.UpdateTagToLabelRequest) (*configv1.UpdateTagToLabelResponse, error) {
	id := req.Id
	s.TagToLabelMutex.Lock()
	model, found := s.TagToLabelMap[id]
	if !found {
		s.TagToLabelMutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "tag_to_label"),
			zap.String("method", "UpdateTagToLabel"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no tag_to_label found with id %s", id)
	}
	updateMask := req.UpdateMask
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		case "aws_tag_keys":
			model.AwsTagKeys = req.AwsTagKeys
		case "azure_tag_keys":
			model.AzureTagKeys = req.AzureTagKeys
		case "icon":
			model.Icon = req.Icon
		case "key":
			model.Key = req.Key
		case "name":
			model.Name = req.Name
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "tag_to_label"),
				zap.String("method", "UpdateTagToLabel"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for tag_to_label: %s", path)
		}
	}
	resp := &configv1.UpdateTagToLabelResponse{
		Id:           id,
		AwsTagKeys:   model.AwsTagKeys,
		AzureTagKeys: model.AzureTagKeys,
		Icon:         model.Icon,
		Key:          model.Key,
		Name:         model.Name,
	}
	s.TagToLabelMutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "tag_to_label"),
		zap.String("method", "UpdateTagToLabel"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *FakeConfigServer) DeleteTagToLabel(ctx context.Context, req *configv1.DeleteTagToLabelRequest) (*emptypb.Empty, error) {
	id := req.Id
	s.TagToLabelMutex.Lock()
	_, found := s.TagToLabelMap[id]
	if !found {
		s.TagToLabelMutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "tag_to_label"),
			zap.String("method", "DeleteTagToLabel"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no tag_to_label found with id %s", id)
	}
	delete(s.TagToLabelMap, id)
	s.TagToLabelMutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "tag_to_label"),
		zap.String("method", "DeleteTagToLabel"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
