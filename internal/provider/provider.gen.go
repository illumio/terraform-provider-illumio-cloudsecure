// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0
// Code generated by providergen. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	resource_schema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	configv1 "github.com/illumio/terraform-provider-illumio-cloudsecure/api/illumio/cloud/config/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
)

// ProviderData is the state of the provider, which is passed to resources and data sources at runtime as their ProviderData.
type ProviderData interface {
	// Client returns the CloudSecure Config API client.
	Client() configv1.ConfigServiceClient

	// RequestTimeout returns the maximum duration of each API request.
	RequestTimeout() time.Duration
}

func (p *Provider) Resources(ctx context.Context) []func() resource.Resource {
	resources := p.schema.Resources()
	resp := make([]func() resource.Resource, 0, len(resources))
	for _, r := range resources {
		switch r.TypeName {
		case "aws_account":
			resp = append(resp, func() resource.Resource { return NewAwsAccountResource(r.Schema) })
		case "aws_flow_logs_s3_bucket":
			resp = append(resp, func() resource.Resource { return NewAwsFlowLogsS3BucketResource(r.Schema) })
		case "aws_tag_to_label":
			resp = append(resp, func() resource.Resource { return NewAwsTagToLabelResource(r.Schema) })
		case "azure_flow_logs_storage_account":
			resp = append(resp, func() resource.Resource { return NewAzureFlowLogsStorageAccountResource(r.Schema) })
		case "azure_subscription":
			resp = append(resp, func() resource.Resource { return NewAzureSubscriptionResource(r.Schema) })
		case "k8s_cluster_onboarding_credential":
			resp = append(resp, func() resource.Resource { return NewK8SClusterOnboardingCredentialResource(r.Schema) })
		}
	}
	return resp
}

func (p *Provider) DataSources(ctx context.Context) []func() datasource.DataSource {
	return []func() datasource.DataSource{
		// TODO: Add support for data sources.
	}
}

// AwsAccountResource implements the aws_account resource.
type AwsAccountResource struct {
	// schema is the schema of the aws_account resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &AwsAccountResource{}
var _ resource.ResourceWithImportState = &AwsAccountResource{}

// NewAwsAccountResource returns a new aws_account resource.
func NewAwsAccountResource(schema resource_schema.Schema) resource.Resource {
	return &AwsAccountResource{
		schema: schema,
	}
}

func (r *AwsAccountResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aws_account"
}

func (r *AwsAccountResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *AwsAccountResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *AwsAccountResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AwsAccountResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagReq := NewCreateAwsAccountRequest(ctx, &data)
	resp.Diagnostics.Append(diagReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "aws_account"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create aws_account, got error: %s", err))
		return
	}

	CopyCreateAwsAccountResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "aws_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsAccountResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AwsAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagsReq := NewReadAwsAccountRequest(ctx, &data)
	resp.Diagnostics.Append(diagsReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "aws_account", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No aws_account found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read aws_account, got error: %s", err))
			return
		}
	}

	CopyReadAwsAccountResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "aws_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsAccountResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData AwsAccountResourceModel
	var afterData AwsAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewUpdateAwsAccountRequest(ctx, &beforeData, &afterData)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "aws_account", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No aws_account found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update aws_account, got error: %s", err))
			return
		}
	}

	CopyUpdateAwsAccountResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "aws_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *AwsAccountResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AwsAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewDeleteAwsAccountRequest(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "aws_account", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "aws_account", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete aws_account, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "aws_account", "id": protoReq.Id})
}

func (r *AwsAccountResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

// AwsFlowLogsS3BucketResource implements the aws_flow_logs_s3_bucket resource.
type AwsFlowLogsS3BucketResource struct {
	// schema is the schema of the aws_flow_logs_s3_bucket resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &AwsFlowLogsS3BucketResource{}
var _ resource.ResourceWithImportState = &AwsFlowLogsS3BucketResource{}

// NewAwsFlowLogsS3BucketResource returns a new aws_flow_logs_s3_bucket resource.
func NewAwsFlowLogsS3BucketResource(schema resource_schema.Schema) resource.Resource {
	return &AwsFlowLogsS3BucketResource{
		schema: schema,
	}
}

func (r *AwsFlowLogsS3BucketResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aws_flow_logs_s3_bucket"
}

func (r *AwsFlowLogsS3BucketResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *AwsFlowLogsS3BucketResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *AwsFlowLogsS3BucketResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AwsFlowLogsS3BucketResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagReq := NewCreateAwsFlowLogsS3BucketRequest(ctx, &data)
	resp.Diagnostics.Append(diagReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "aws_flow_logs_s3_bucket"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateAwsFlowLogsS3Bucket(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create aws_flow_logs_s3_bucket, got error: %s", err))
		return
	}

	CopyCreateAwsFlowLogsS3BucketResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsFlowLogsS3BucketResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AwsFlowLogsS3BucketResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagsReq := NewReadAwsFlowLogsS3BucketRequest(ctx, &data)
	resp.Diagnostics.Append(diagsReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadAwsFlowLogsS3Bucket(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No aws_flow_logs_s3_bucket found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read aws_flow_logs_s3_bucket, got error: %s", err))
			return
		}
	}

	CopyReadAwsFlowLogsS3BucketResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsFlowLogsS3BucketResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData AwsFlowLogsS3BucketResourceModel
	var afterData AwsFlowLogsS3BucketResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewUpdateAwsFlowLogsS3BucketRequest(ctx, &beforeData, &afterData)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateAwsFlowLogsS3Bucket(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No aws_flow_logs_s3_bucket found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update aws_flow_logs_s3_bucket, got error: %s", err))
			return
		}
	}

	CopyUpdateAwsFlowLogsS3BucketResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *AwsFlowLogsS3BucketResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AwsFlowLogsS3BucketResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewDeleteAwsFlowLogsS3BucketRequest(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteAwsFlowLogsS3Bucket(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete aws_flow_logs_s3_bucket, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "aws_flow_logs_s3_bucket", "id": protoReq.Id})
}

func (r *AwsFlowLogsS3BucketResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

// AwsTagToLabelResource implements the aws_tag_to_label resource.
type AwsTagToLabelResource struct {
	// schema is the schema of the aws_tag_to_label resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &AwsTagToLabelResource{}
var _ resource.ResourceWithImportState = &AwsTagToLabelResource{}

// NewAwsTagToLabelResource returns a new aws_tag_to_label resource.
func NewAwsTagToLabelResource(schema resource_schema.Schema) resource.Resource {
	return &AwsTagToLabelResource{
		schema: schema,
	}
}

func (r *AwsTagToLabelResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aws_tag_to_label"
}

func (r *AwsTagToLabelResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *AwsTagToLabelResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *AwsTagToLabelResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AwsTagToLabelResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagReq := NewCreateAwsTagToLabelRequest(ctx, &data)
	resp.Diagnostics.Append(diagReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "aws_tag_to_label"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateAwsTagToLabel(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create aws_tag_to_label, got error: %s", err))
		return
	}

	CopyCreateAwsTagToLabelResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "aws_tag_to_label", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsTagToLabelResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AwsTagToLabelResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagsReq := NewReadAwsTagToLabelRequest(ctx, &data)
	resp.Diagnostics.Append(diagsReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "aws_tag_to_label", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadAwsTagToLabel(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No aws_tag_to_label found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read aws_tag_to_label, got error: %s", err))
			return
		}
	}

	CopyReadAwsTagToLabelResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "aws_tag_to_label", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsTagToLabelResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData AwsTagToLabelResourceModel
	var afterData AwsTagToLabelResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewUpdateAwsTagToLabelRequest(ctx, &beforeData, &afterData)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "aws_tag_to_label", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateAwsTagToLabel(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No aws_tag_to_label found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update aws_tag_to_label, got error: %s", err))
			return
		}
	}

	CopyUpdateAwsTagToLabelResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "aws_tag_to_label", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *AwsTagToLabelResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AwsTagToLabelResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewDeleteAwsTagToLabelRequest(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "aws_tag_to_label", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteAwsTagToLabel(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "aws_tag_to_label", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete aws_tag_to_label, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "aws_tag_to_label", "id": protoReq.Id})
}

func (r *AwsTagToLabelResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

// AzureFlowLogsStorageAccountResource implements the azure_flow_logs_storage_account resource.
type AzureFlowLogsStorageAccountResource struct {
	// schema is the schema of the azure_flow_logs_storage_account resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &AzureFlowLogsStorageAccountResource{}
var _ resource.ResourceWithImportState = &AzureFlowLogsStorageAccountResource{}

// NewAzureFlowLogsStorageAccountResource returns a new azure_flow_logs_storage_account resource.
func NewAzureFlowLogsStorageAccountResource(schema resource_schema.Schema) resource.Resource {
	return &AzureFlowLogsStorageAccountResource{
		schema: schema,
	}
}

func (r *AzureFlowLogsStorageAccountResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_azure_flow_logs_storage_account"
}

func (r *AzureFlowLogsStorageAccountResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *AzureFlowLogsStorageAccountResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *AzureFlowLogsStorageAccountResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AzureFlowLogsStorageAccountResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagReq := NewCreateAzureFlowLogsStorageAccountRequest(ctx, &data)
	resp.Diagnostics.Append(diagReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "azure_flow_logs_storage_account"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateAzureFlowLogsStorageAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create azure_flow_logs_storage_account, got error: %s", err))
		return
	}

	CopyCreateAzureFlowLogsStorageAccountResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureFlowLogsStorageAccountResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AzureFlowLogsStorageAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagsReq := NewReadAzureFlowLogsStorageAccountRequest(ctx, &data)
	resp.Diagnostics.Append(diagsReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadAzureFlowLogsStorageAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No azure_flow_logs_storage_account found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read azure_flow_logs_storage_account, got error: %s", err))
			return
		}
	}

	CopyReadAzureFlowLogsStorageAccountResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureFlowLogsStorageAccountResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData AzureFlowLogsStorageAccountResourceModel
	var afterData AzureFlowLogsStorageAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewUpdateAzureFlowLogsStorageAccountRequest(ctx, &beforeData, &afterData)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateAzureFlowLogsStorageAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No azure_flow_logs_storage_account found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update azure_flow_logs_storage_account, got error: %s", err))
			return
		}
	}

	CopyUpdateAzureFlowLogsStorageAccountResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *AzureFlowLogsStorageAccountResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AzureFlowLogsStorageAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewDeleteAzureFlowLogsStorageAccountRequest(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteAzureFlowLogsStorageAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete azure_flow_logs_storage_account, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "azure_flow_logs_storage_account", "id": protoReq.Id})
}

func (r *AzureFlowLogsStorageAccountResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

// AzureSubscriptionResource implements the azure_subscription resource.
type AzureSubscriptionResource struct {
	// schema is the schema of the azure_subscription resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &AzureSubscriptionResource{}
var _ resource.ResourceWithImportState = &AzureSubscriptionResource{}

// NewAzureSubscriptionResource returns a new azure_subscription resource.
func NewAzureSubscriptionResource(schema resource_schema.Schema) resource.Resource {
	return &AzureSubscriptionResource{
		schema: schema,
	}
}

func (r *AzureSubscriptionResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_azure_subscription"
}

func (r *AzureSubscriptionResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *AzureSubscriptionResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *AzureSubscriptionResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AzureSubscriptionResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagReq := NewCreateAzureSubscriptionRequest(ctx, &data)
	resp.Diagnostics.Append(diagReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "azure_subscription"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateAzureSubscription(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create azure_subscription, got error: %s", err))
		return
	}

	CopyCreateAzureSubscriptionResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "azure_subscription", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureSubscriptionResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AzureSubscriptionResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagsReq := NewReadAzureSubscriptionRequest(ctx, &data)
	resp.Diagnostics.Append(diagsReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "azure_subscription", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadAzureSubscription(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No azure_subscription found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read azure_subscription, got error: %s", err))
			return
		}
	}

	CopyReadAzureSubscriptionResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "azure_subscription", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AzureSubscriptionResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData AzureSubscriptionResourceModel
	var afterData AzureSubscriptionResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewUpdateAzureSubscriptionRequest(ctx, &beforeData, &afterData)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "azure_subscription", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateAzureSubscription(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No azure_subscription found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update azure_subscription, got error: %s", err))
			return
		}
	}

	CopyUpdateAzureSubscriptionResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "azure_subscription", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *AzureSubscriptionResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AzureSubscriptionResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewDeleteAzureSubscriptionRequest(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "azure_subscription", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteAzureSubscription(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "azure_subscription", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete azure_subscription, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "azure_subscription", "id": protoReq.Id})
}

func (r *AzureSubscriptionResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

// K8SClusterOnboardingCredentialResource implements the k8s_cluster_onboarding_credential resource.
type K8SClusterOnboardingCredentialResource struct {
	// schema is the schema of the k8s_cluster_onboarding_credential resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &K8SClusterOnboardingCredentialResource{}
var _ resource.ResourceWithImportState = &K8SClusterOnboardingCredentialResource{}

// NewK8SClusterOnboardingCredentialResource returns a new k8s_cluster_onboarding_credential resource.
func NewK8SClusterOnboardingCredentialResource(schema resource_schema.Schema) resource.Resource {
	return &K8SClusterOnboardingCredentialResource{
		schema: schema,
	}
}

func (r *K8SClusterOnboardingCredentialResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_k8s_cluster_onboarding_credential"
}

func (r *K8SClusterOnboardingCredentialResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *K8SClusterOnboardingCredentialResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *K8SClusterOnboardingCredentialResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data K8SClusterOnboardingCredentialResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagReq := NewCreateK8SClusterOnboardingCredentialRequest(ctx, &data)
	resp.Diagnostics.Append(diagReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "k8s_cluster_onboarding_credential"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateK8SClusterOnboardingCredential(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create k8s_cluster_onboarding_credential, got error: %s", err))
		return
	}

	CopyCreateK8SClusterOnboardingCredentialResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *K8SClusterOnboardingCredentialResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data K8SClusterOnboardingCredentialResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diagsReq := NewReadK8SClusterOnboardingCredentialRequest(ctx, &data)
	resp.Diagnostics.Append(diagsReq...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadK8SClusterOnboardingCredential(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No k8s_cluster_onboarding_credential found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read k8s_cluster_onboarding_credential, got error: %s", err))
			return
		}
	}

	CopyReadK8SClusterOnboardingCredentialResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *K8SClusterOnboardingCredentialResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData K8SClusterOnboardingCredentialResourceModel
	var afterData K8SClusterOnboardingCredentialResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewUpdateK8SClusterOnboardingCredentialRequest(ctx, &beforeData, &afterData)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateK8SClusterOnboardingCredential(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No k8s_cluster_onboarding_credential found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update k8s_cluster_onboarding_credential, got error: %s", err))
			return
		}
	}

	CopyUpdateK8SClusterOnboardingCredentialResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *K8SClusterOnboardingCredentialResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data K8SClusterOnboardingCredentialResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq, diags := NewDeleteK8SClusterOnboardingCredentialRequest(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteK8SClusterOnboardingCredential(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete k8s_cluster_onboarding_credential, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "k8s_cluster_onboarding_credential", "id": protoReq.Id})
}

func (r *K8SClusterOnboardingCredentialResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

type AwsAccountResourceModel struct {
	Id             types.String `tfsdk:"id"`
	AccountId      types.String `tfsdk:"account_id"`
	Mode           types.String `tfsdk:"mode"`
	Name           types.String `tfsdk:"name"`
	OrganizationId types.String `tfsdk:"organization_id"`
	RoleArn        types.String `tfsdk:"role_arn"`
	RoleExternalId types.String `tfsdk:"role_external_id"`
}

type AwsFlowLogsS3BucketResourceModel struct {
	Id          types.String `tfsdk:"id"`
	AccountId   types.String `tfsdk:"account_id"`
	S3BucketArn types.String `tfsdk:"s3_bucket_arn"`
}

type AwsTagToLabelResourceModel struct {
	Id        types.String `tfsdk:"id"`
	CloudTags types.List   `tfsdk:"cloud_tags"`
	Icon      types.Object `tfsdk:"icon"`
	Key       types.String `tfsdk:"key"`
	Name      types.String `tfsdk:"name"`
}

type AzureFlowLogsStorageAccountResourceModel struct {
	Id                       types.String `tfsdk:"id"`
	StorageAccountResourceId types.String `tfsdk:"storage_account_resource_id"`
	SubscriptionId           types.String `tfsdk:"subscription_id"`
}

type AzureSubscriptionResourceModel struct {
	Id             types.String `tfsdk:"id"`
	ClientId       types.String `tfsdk:"client_id"`
	ClientSecret   types.String `tfsdk:"client_secret"`
	Mode           types.String `tfsdk:"mode"`
	Name           types.String `tfsdk:"name"`
	SubscriptionId types.String `tfsdk:"subscription_id"`
	TenantId       types.String `tfsdk:"tenant_id"`
}

type K8SClusterOnboardingCredentialResourceModel struct {
	Id            types.String `tfsdk:"id"`
	ClientId      types.String `tfsdk:"client_id"`
	ClientSecret  types.String `tfsdk:"client_secret"`
	CreatedAt     types.String `tfsdk:"created_at"`
	Description   types.String `tfsdk:"description"`
	IllumioRegion types.String `tfsdk:"illumio_region"`
	Name          types.String `tfsdk:"name"`
}

func NewCreateAwsAccountRequest(ctx context.Context, data *AwsAccountResourceModel) (*configv1.CreateAwsAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.CreateAwsAccountRequest{}
	if !data.AccountId.IsUnknown() && !data.AccountId.IsNull() {
		var dataValue attr.Value = data.AccountId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.AccountId = protoValue
	}
	if !data.Mode.IsUnknown() && !data.Mode.IsNull() {
		var dataValue attr.Value = data.Mode
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Mode = protoValue
	}
	if !data.Name.IsUnknown() && !data.Name.IsNull() {
		var dataValue attr.Value = data.Name
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Name = protoValue
	}
	if !data.OrganizationId.IsUnknown() && !data.OrganizationId.IsNull() {
		var dataValue attr.Value = data.OrganizationId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.OrganizationId = &protoValue
	}
	if !data.RoleArn.IsUnknown() && !data.RoleArn.IsNull() {
		var dataValue attr.Value = data.RoleArn
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.RoleArn = protoValue
	}
	if !data.RoleExternalId.IsUnknown() && !data.RoleExternalId.IsNull() {
		var dataValue attr.Value = data.RoleExternalId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.RoleExternalId = protoValue
	}
	return proto, diags
}

func NewReadAwsAccountRequest(ctx context.Context, data *AwsAccountResourceModel) (*configv1.ReadAwsAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.ReadAwsAccountRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewDeleteAwsAccountRequest(ctx context.Context, data *AwsAccountResourceModel) (*configv1.DeleteAwsAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.DeleteAwsAccountRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewCreateAwsFlowLogsS3BucketRequest(ctx context.Context, data *AwsFlowLogsS3BucketResourceModel) (*configv1.CreateAwsFlowLogsS3BucketRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.CreateAwsFlowLogsS3BucketRequest{}
	if !data.AccountId.IsUnknown() && !data.AccountId.IsNull() {
		var dataValue attr.Value = data.AccountId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.AccountId = protoValue
	}
	if !data.S3BucketArn.IsUnknown() && !data.S3BucketArn.IsNull() {
		var dataValue attr.Value = data.S3BucketArn
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.S3BucketArn = protoValue
	}
	return proto, diags
}

func NewReadAwsFlowLogsS3BucketRequest(ctx context.Context, data *AwsFlowLogsS3BucketResourceModel) (*configv1.ReadAwsFlowLogsS3BucketRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.ReadAwsFlowLogsS3BucketRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewDeleteAwsFlowLogsS3BucketRequest(ctx context.Context, data *AwsFlowLogsS3BucketResourceModel) (*configv1.DeleteAwsFlowLogsS3BucketRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.DeleteAwsFlowLogsS3BucketRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewCreateAwsTagToLabelRequest(ctx context.Context, data *AwsTagToLabelResourceModel) (*configv1.CreateAwsTagToLabelRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.CreateAwsTagToLabelRequest{}
	if !data.CloudTags.IsUnknown() && !data.CloudTags.IsNull() {
		var dataValue attr.Value = data.CloudTags
		var protoValue []*configv1.AwsTagToLabel_CloudTags
		{
			dataElements := dataValue.(types.List).Elements()
			protoValues := make([]*configv1.AwsTagToLabel_CloudTags, 0, len(dataElements))
			for _, dataElement := range dataElements {
				var dataValue attr.Value = dataElement
				var protoValue *configv1.AwsTagToLabel_CloudTags
				protoValue, newDiags := ConvertDataValueToAwsTagToLabel_CloudTagsProto(ctx, dataValue)
				diags.Append(newDiags...)
				if diags.HasError() {
					return nil, diags
				}
				protoValues = append(protoValues, protoValue)
			}
			protoValue = protoValues
		}
		proto.CloudTags = protoValue
	}
	if !data.Icon.IsUnknown() && !data.Icon.IsNull() {
		var dataValue attr.Value = data.Icon
		var protoValue *configv1.AwsTagToLabel_Icon
		protoValue, newDiags := ConvertDataValueToAwsTagToLabel_IconProto(ctx, dataValue)
		diags.Append(newDiags...)
		if diags.HasError() {
			return nil, diags
		}
		proto.Icon = protoValue
	}
	if !data.Key.IsUnknown() && !data.Key.IsNull() {
		var dataValue attr.Value = data.Key
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Key = protoValue
	}
	if !data.Name.IsUnknown() && !data.Name.IsNull() {
		var dataValue attr.Value = data.Name
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Name = protoValue
	}
	return proto, diags
}

func NewReadAwsTagToLabelRequest(ctx context.Context, data *AwsTagToLabelResourceModel) (*configv1.ReadAwsTagToLabelRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.ReadAwsTagToLabelRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewDeleteAwsTagToLabelRequest(ctx context.Context, data *AwsTagToLabelResourceModel) (*configv1.DeleteAwsTagToLabelRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.DeleteAwsTagToLabelRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewCreateAzureFlowLogsStorageAccountRequest(ctx context.Context, data *AzureFlowLogsStorageAccountResourceModel) (*configv1.CreateAzureFlowLogsStorageAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.CreateAzureFlowLogsStorageAccountRequest{}
	if !data.StorageAccountResourceId.IsUnknown() && !data.StorageAccountResourceId.IsNull() {
		var dataValue attr.Value = data.StorageAccountResourceId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.StorageAccountResourceId = protoValue
	}
	if !data.SubscriptionId.IsUnknown() && !data.SubscriptionId.IsNull() {
		var dataValue attr.Value = data.SubscriptionId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.SubscriptionId = protoValue
	}
	return proto, diags
}

func NewReadAzureFlowLogsStorageAccountRequest(ctx context.Context, data *AzureFlowLogsStorageAccountResourceModel) (*configv1.ReadAzureFlowLogsStorageAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.ReadAzureFlowLogsStorageAccountRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewDeleteAzureFlowLogsStorageAccountRequest(ctx context.Context, data *AzureFlowLogsStorageAccountResourceModel) (*configv1.DeleteAzureFlowLogsStorageAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.DeleteAzureFlowLogsStorageAccountRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewCreateAzureSubscriptionRequest(ctx context.Context, data *AzureSubscriptionResourceModel) (*configv1.CreateAzureSubscriptionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.CreateAzureSubscriptionRequest{}
	if !data.ClientId.IsUnknown() && !data.ClientId.IsNull() {
		var dataValue attr.Value = data.ClientId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.ClientId = protoValue
	}
	if !data.ClientSecret.IsUnknown() && !data.ClientSecret.IsNull() {
		var dataValue attr.Value = data.ClientSecret
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.ClientSecret = protoValue
	}
	if !data.Mode.IsUnknown() && !data.Mode.IsNull() {
		var dataValue attr.Value = data.Mode
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Mode = protoValue
	}
	if !data.Name.IsUnknown() && !data.Name.IsNull() {
		var dataValue attr.Value = data.Name
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Name = protoValue
	}
	if !data.SubscriptionId.IsUnknown() && !data.SubscriptionId.IsNull() {
		var dataValue attr.Value = data.SubscriptionId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.SubscriptionId = protoValue
	}
	if !data.TenantId.IsUnknown() && !data.TenantId.IsNull() {
		var dataValue attr.Value = data.TenantId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.TenantId = protoValue
	}
	return proto, diags
}

func NewReadAzureSubscriptionRequest(ctx context.Context, data *AzureSubscriptionResourceModel) (*configv1.ReadAzureSubscriptionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.ReadAzureSubscriptionRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewDeleteAzureSubscriptionRequest(ctx context.Context, data *AzureSubscriptionResourceModel) (*configv1.DeleteAzureSubscriptionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.DeleteAzureSubscriptionRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewCreateK8SClusterOnboardingCredentialRequest(ctx context.Context, data *K8SClusterOnboardingCredentialResourceModel) (*configv1.CreateK8SClusterOnboardingCredentialRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.CreateK8SClusterOnboardingCredentialRequest{}
	if !data.Description.IsUnknown() && !data.Description.IsNull() {
		var dataValue attr.Value = data.Description
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Description = &protoValue
	}
	if !data.IllumioRegion.IsUnknown() && !data.IllumioRegion.IsNull() {
		var dataValue attr.Value = data.IllumioRegion
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.IllumioRegion = protoValue
	}
	if !data.Name.IsUnknown() && !data.Name.IsNull() {
		var dataValue attr.Value = data.Name
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Name = protoValue
	}
	return proto, diags
}

func NewReadK8SClusterOnboardingCredentialRequest(ctx context.Context, data *K8SClusterOnboardingCredentialResourceModel) (*configv1.ReadK8SClusterOnboardingCredentialRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.ReadK8SClusterOnboardingCredentialRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewDeleteK8SClusterOnboardingCredentialRequest(ctx context.Context, data *K8SClusterOnboardingCredentialResourceModel) (*configv1.DeleteK8SClusterOnboardingCredentialRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.DeleteK8SClusterOnboardingCredentialRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto, diags
}

func NewUpdateAwsAccountRequest(ctx context.Context, beforeData, afterData *AwsAccountResourceModel) (*configv1.UpdateAwsAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.UpdateAwsAccountRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	if !afterData.Name.Equal(beforeData.Name) {
		proto.UpdateMask.Append(proto, "name")
		if !afterData.Name.IsUnknown() && !afterData.Name.IsNull() {
			var dataValue attr.Value = afterData.Name
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Name = protoValue
		}
	}
	return proto, diags
}

func NewUpdateAwsFlowLogsS3BucketRequest(ctx context.Context, beforeData, afterData *AwsFlowLogsS3BucketResourceModel) (*configv1.UpdateAwsFlowLogsS3BucketRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.UpdateAwsFlowLogsS3BucketRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	return proto, diags
}

func NewUpdateAwsTagToLabelRequest(ctx context.Context, beforeData, afterData *AwsTagToLabelResourceModel) (*configv1.UpdateAwsTagToLabelRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.UpdateAwsTagToLabelRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	if !afterData.CloudTags.Equal(beforeData.CloudTags) {
		proto.UpdateMask.Append(proto, "cloud_tags")
		if !afterData.CloudTags.IsUnknown() && !afterData.CloudTags.IsNull() {
			var dataValue attr.Value = afterData.CloudTags
			var protoValue []*configv1.AwsTagToLabel_CloudTags
			{
				dataElements := dataValue.(types.List).Elements()
				protoValues := make([]*configv1.AwsTagToLabel_CloudTags, 0, len(dataElements))
				for _, dataElement := range dataElements {
					var dataValue attr.Value = dataElement
					var protoValue *configv1.AwsTagToLabel_CloudTags
					protoValue, newDiags := ConvertDataValueToAwsTagToLabel_CloudTagsProto(ctx, dataValue)
					diags.Append(newDiags...)
					if diags.HasError() {
						return nil, diags
					}
					protoValues = append(protoValues, protoValue)
				}
				protoValue = protoValues
			}
			proto.CloudTags = protoValue
		}
	}
	if !afterData.Icon.Equal(beforeData.Icon) {
		proto.UpdateMask.Append(proto, "icon")
		if !afterData.Icon.IsUnknown() && !afterData.Icon.IsNull() {
			var dataValue attr.Value = afterData.Icon
			var protoValue *configv1.AwsTagToLabel_Icon
			protoValue, newDiags := ConvertDataValueToAwsTagToLabel_IconProto(ctx, dataValue)
			diags.Append(newDiags...)
			if diags.HasError() {
				return nil, diags
			}
			proto.Icon = protoValue
		}
	}
	if !afterData.Key.Equal(beforeData.Key) {
		proto.UpdateMask.Append(proto, "key")
		if !afterData.Key.IsUnknown() && !afterData.Key.IsNull() {
			var dataValue attr.Value = afterData.Key
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Key = protoValue
		}
	}
	if !afterData.Name.Equal(beforeData.Name) {
		proto.UpdateMask.Append(proto, "name")
		if !afterData.Name.IsUnknown() && !afterData.Name.IsNull() {
			var dataValue attr.Value = afterData.Name
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Name = protoValue
		}
	}
	return proto, diags
}

func NewUpdateAzureFlowLogsStorageAccountRequest(ctx context.Context, beforeData, afterData *AzureFlowLogsStorageAccountResourceModel) (*configv1.UpdateAzureFlowLogsStorageAccountRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.UpdateAzureFlowLogsStorageAccountRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	return proto, diags
}

func NewUpdateAzureSubscriptionRequest(ctx context.Context, beforeData, afterData *AzureSubscriptionResourceModel) (*configv1.UpdateAzureSubscriptionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.UpdateAzureSubscriptionRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	if !afterData.Name.Equal(beforeData.Name) {
		proto.UpdateMask.Append(proto, "name")
		if !afterData.Name.IsUnknown() && !afterData.Name.IsNull() {
			var dataValue attr.Value = afterData.Name
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Name = protoValue
		}
	}
	return proto, diags
}

func NewUpdateK8SClusterOnboardingCredentialRequest(ctx context.Context, beforeData, afterData *K8SClusterOnboardingCredentialResourceModel) (*configv1.UpdateK8SClusterOnboardingCredentialRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	proto := &configv1.UpdateK8SClusterOnboardingCredentialRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	if !afterData.Description.Equal(beforeData.Description) {
		proto.UpdateMask.Append(proto, "description")
		if !afterData.Description.IsUnknown() && !afterData.Description.IsNull() {
			var dataValue attr.Value = afterData.Description
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Description = &protoValue
		}
	}
	if !afterData.Name.Equal(beforeData.Name) {
		proto.UpdateMask.Append(proto, "name")
		if !afterData.Name.IsUnknown() && !afterData.Name.IsNull() {
			var dataValue attr.Value = afterData.Name
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Name = protoValue
		}
	}
	return proto, diags
}
func CopyCreateAwsAccountResponse(dst *AwsAccountResourceModel, src *configv1.CreateAwsAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.Mode = types.StringValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.OrganizationId = types.StringPointerValue(src.OrganizationId)
	dst.RoleArn = types.StringValue(src.RoleArn)
}
func CopyReadAwsAccountResponse(dst *AwsAccountResourceModel, src *configv1.ReadAwsAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.Mode = types.StringValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.OrganizationId = types.StringPointerValue(src.OrganizationId)
	dst.RoleArn = types.StringValue(src.RoleArn)
}
func CopyUpdateAwsAccountResponse(dst *AwsAccountResourceModel, src *configv1.UpdateAwsAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.Mode = types.StringValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.OrganizationId = types.StringPointerValue(src.OrganizationId)
	dst.RoleArn = types.StringValue(src.RoleArn)
}
func CopyCreateAwsFlowLogsS3BucketResponse(dst *AwsFlowLogsS3BucketResourceModel, src *configv1.CreateAwsFlowLogsS3BucketResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.S3BucketArn = types.StringValue(src.S3BucketArn)
}
func CopyReadAwsFlowLogsS3BucketResponse(dst *AwsFlowLogsS3BucketResourceModel, src *configv1.ReadAwsFlowLogsS3BucketResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.S3BucketArn = types.StringValue(src.S3BucketArn)
}
func CopyUpdateAwsFlowLogsS3BucketResponse(dst *AwsFlowLogsS3BucketResourceModel, src *configv1.UpdateAwsFlowLogsS3BucketResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.S3BucketArn = types.StringValue(src.S3BucketArn)
}
func CopyCreateAwsTagToLabelResponse(dst *AwsTagToLabelResourceModel, src *configv1.CreateAwsTagToLabelResponse) {
	dst.Id = types.StringValue(src.Id)
	{
		protoValue := src.CloudTags
		var dataValue types.List
		{
			dataElementType := types.ObjectType{
				AttrTypes: GetTypeAttrsForAwsTagToLabel_CloudTags(),
			}
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.ListNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue *configv1.AwsTagToLabel_CloudTags = protoElement
					var dataValue attr.Value
					dataValue = ConvertAwsTagToLabel_CloudTagsToObjectValueFromProto(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.ListValueMust(dataElementType, dataValues)
			}
		}
		dst.CloudTags = dataValue
	}
	dst.Icon = ConvertAwsTagToLabel_IconToObjectValueFromProto(src.Icon)
	dst.Key = types.StringValue(src.Key)
	dst.Name = types.StringValue(src.Name)
}
func CopyReadAwsTagToLabelResponse(dst *AwsTagToLabelResourceModel, src *configv1.ReadAwsTagToLabelResponse) {
	dst.Id = types.StringValue(src.Id)
	{
		protoValue := src.CloudTags
		var dataValue types.List
		{
			dataElementType := types.ObjectType{
				AttrTypes: GetTypeAttrsForAwsTagToLabel_CloudTags(),
			}
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.ListNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue *configv1.AwsTagToLabel_CloudTags = protoElement
					var dataValue attr.Value
					dataValue = ConvertAwsTagToLabel_CloudTagsToObjectValueFromProto(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.ListValueMust(dataElementType, dataValues)
			}
		}
		dst.CloudTags = dataValue
	}
	dst.Icon = ConvertAwsTagToLabel_IconToObjectValueFromProto(src.Icon)
	dst.Key = types.StringValue(src.Key)
	dst.Name = types.StringValue(src.Name)
}
func CopyUpdateAwsTagToLabelResponse(dst *AwsTagToLabelResourceModel, src *configv1.UpdateAwsTagToLabelResponse) {
	dst.Id = types.StringValue(src.Id)
	{
		protoValue := src.CloudTags
		var dataValue types.List
		{
			dataElementType := types.ObjectType{
				AttrTypes: GetTypeAttrsForAwsTagToLabel_CloudTags(),
			}
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.ListNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue *configv1.AwsTagToLabel_CloudTags = protoElement
					var dataValue attr.Value
					dataValue = ConvertAwsTagToLabel_CloudTagsToObjectValueFromProto(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.ListValueMust(dataElementType, dataValues)
			}
		}
		dst.CloudTags = dataValue
	}
	dst.Icon = ConvertAwsTagToLabel_IconToObjectValueFromProto(src.Icon)
	dst.Key = types.StringValue(src.Key)
	dst.Name = types.StringValue(src.Name)
}
func CopyCreateAzureFlowLogsStorageAccountResponse(dst *AzureFlowLogsStorageAccountResourceModel, src *configv1.CreateAzureFlowLogsStorageAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.StorageAccountResourceId = types.StringValue(src.StorageAccountResourceId)
	dst.SubscriptionId = types.StringValue(src.SubscriptionId)
}
func CopyReadAzureFlowLogsStorageAccountResponse(dst *AzureFlowLogsStorageAccountResourceModel, src *configv1.ReadAzureFlowLogsStorageAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.StorageAccountResourceId = types.StringValue(src.StorageAccountResourceId)
	dst.SubscriptionId = types.StringValue(src.SubscriptionId)
}
func CopyUpdateAzureFlowLogsStorageAccountResponse(dst *AzureFlowLogsStorageAccountResourceModel, src *configv1.UpdateAzureFlowLogsStorageAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.StorageAccountResourceId = types.StringValue(src.StorageAccountResourceId)
	dst.SubscriptionId = types.StringValue(src.SubscriptionId)
}
func CopyCreateAzureSubscriptionResponse(dst *AzureSubscriptionResourceModel, src *configv1.CreateAzureSubscriptionResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.ClientId = types.StringValue(src.ClientId)
	dst.Mode = types.StringValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.SubscriptionId = types.StringValue(src.SubscriptionId)
	dst.TenantId = types.StringValue(src.TenantId)
}
func CopyReadAzureSubscriptionResponse(dst *AzureSubscriptionResourceModel, src *configv1.ReadAzureSubscriptionResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.ClientId = types.StringValue(src.ClientId)
	dst.Mode = types.StringValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.SubscriptionId = types.StringValue(src.SubscriptionId)
	dst.TenantId = types.StringValue(src.TenantId)
}
func CopyUpdateAzureSubscriptionResponse(dst *AzureSubscriptionResourceModel, src *configv1.UpdateAzureSubscriptionResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.ClientId = types.StringValue(src.ClientId)
	dst.Mode = types.StringValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.SubscriptionId = types.StringValue(src.SubscriptionId)
	dst.TenantId = types.StringValue(src.TenantId)
}
func CopyCreateK8SClusterOnboardingCredentialResponse(dst *K8SClusterOnboardingCredentialResourceModel, src *configv1.CreateK8SClusterOnboardingCredentialResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.ClientId = types.StringValue(src.ClientId)
	dst.ClientSecret = types.StringValue(src.ClientSecret)
	dst.CreatedAt = types.StringValue(src.CreatedAt)
	dst.Description = types.StringPointerValue(src.Description)
	dst.IllumioRegion = types.StringValue(src.IllumioRegion)
	dst.Name = types.StringValue(src.Name)
}
func CopyReadK8SClusterOnboardingCredentialResponse(dst *K8SClusterOnboardingCredentialResourceModel, src *configv1.ReadK8SClusterOnboardingCredentialResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.ClientId = types.StringValue(src.ClientId)
	dst.CreatedAt = types.StringValue(src.CreatedAt)
	dst.Description = types.StringPointerValue(src.Description)
	dst.IllumioRegion = types.StringValue(src.IllumioRegion)
	dst.Name = types.StringValue(src.Name)
}
func CopyUpdateK8SClusterOnboardingCredentialResponse(dst *K8SClusterOnboardingCredentialResourceModel, src *configv1.UpdateK8SClusterOnboardingCredentialResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.ClientId = types.StringValue(src.ClientId)
	dst.CreatedAt = types.StringValue(src.CreatedAt)
	dst.Description = types.StringPointerValue(src.Description)
	dst.IllumioRegion = types.StringValue(src.IllumioRegion)
	dst.Name = types.StringValue(src.Name)
}

type AwsTagToLabel_CloudTags struct {
	Cloud types.String `tfsdk:"cloud"`
	Key   types.String `tfsdk:"key"`
}

func GetTypeAttrsForAwsTagToLabel_CloudTags() map[string]attr.Type {
	return map[string]attr.Type{
		"cloud": types.StringType,
		"key":   types.StringType,
	}
}

func ConvertAwsTagToLabel_CloudTagsToObjectValueFromProto(proto *configv1.AwsTagToLabel_CloudTags) basetypes.ObjectValue {
	return types.ObjectValueMust(
		GetTypeAttrsForAwsTagToLabel_CloudTags(),
		map[string]attr.Value{
			"cloud": types.StringValue(proto.Cloud),
			"key":   types.StringValue(proto.Key),
		},
	)
}

func ConvertDataValueToAwsTagToLabel_CloudTagsProto(ctx context.Context, dataValue attr.Value) (*configv1.AwsTagToLabel_CloudTags, diag.Diagnostics) {
	pv := AwsTagToLabel_CloudTags{}
	diags := tfsdk.ValueAs(ctx, dataValue, &pv)
	if diags.HasError() {
		return nil, diags
	}
	proto := &configv1.AwsTagToLabel_CloudTags{}
	proto.Cloud = pv.Cloud.ValueString()
	proto.Key = pv.Key.ValueString()
	return proto, diags
}

type AwsTagToLabel_Icon struct {
	BackgroundColor types.String `tfsdk:"background_color"`
	ForegroundColor types.String `tfsdk:"foreground_color"`
	Name            types.String `tfsdk:"name"`
}

func GetTypeAttrsForAwsTagToLabel_Icon() map[string]attr.Type {
	return map[string]attr.Type{
		"background_color": types.StringType,
		"foreground_color": types.StringType,
		"name":             types.StringType,
	}
}

func ConvertAwsTagToLabel_IconToObjectValueFromProto(proto *configv1.AwsTagToLabel_Icon) basetypes.ObjectValue {
	return types.ObjectValueMust(
		GetTypeAttrsForAwsTagToLabel_Icon(),
		map[string]attr.Value{
			"background_color": types.StringValue(proto.BackgroundColor),
			"foreground_color": types.StringValue(proto.ForegroundColor),
			"name":             types.StringValue(proto.Name),
		},
	)
}

func ConvertDataValueToAwsTagToLabel_IconProto(ctx context.Context, dataValue attr.Value) (*configv1.AwsTagToLabel_Icon, diag.Diagnostics) {
	pv := AwsTagToLabel_Icon{}
	diags := tfsdk.ValueAs(ctx, dataValue, &pv)
	if diags.HasError() {
		return nil, diags
	}
	proto := &configv1.AwsTagToLabel_Icon{}
	proto.BackgroundColor = pv.BackgroundColor.ValueString()
	proto.ForegroundColor = pv.ForegroundColor.ValueString()
	proto.Name = pv.Name.ValueString()
	return proto, diags
}
