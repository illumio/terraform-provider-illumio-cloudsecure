// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0
// Code generated by providergen. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	resource_schema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	configv1 "github.com/illumio/terraform-provider-illumio-cloudsecure/api/illumio/cloud/config/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
)

// ProviderData is the state of the provider, which is passed to resources and data sources at runtime as their ProviderData.
type ProviderData interface {
	// Client returns the CloudSecure Config API client.
	Client() configv1.ConfigServiceClient

	// RequestTimeout returns the maximum duration of each API request.
	RequestTimeout() time.Duration
}

func (p *Provider) Resources(ctx context.Context) []func() resource.Resource {
	resources := p.schema.Resources()
	resp := make([]func() resource.Resource, 0, len(resources))
	for _, r := range resources {
		switch r.TypeName {
		case "aws_account":
			resp = append(resp, func() resource.Resource { return NewAwsAccountResource(r.Schema) })
		}
	}
	return resp
}

func (p *Provider) DataSources(ctx context.Context) []func() datasource.DataSource {
	return []func() datasource.DataSource{
		// TODO: Add support for data sources.
	}
}

// AwsAccountResource implements the aws_account resource.
type AwsAccountResource struct {
	// schema is the schema of the aws_account resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &AwsAccountResource{}
var _ resource.ResourceWithImportState = &AwsAccountResource{}

// NewAwsAccountResource returns a new aws_account resource.
func NewAwsAccountResource(schema resource_schema.Schema) resource.Resource {
	return &AwsAccountResource{
		schema: schema,
	}
}

func (r *AwsAccountResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aws_account"
}

func (r *AwsAccountResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *AwsAccountResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *AwsAccountResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data AwsAccountResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := NewCreateAwsAccountRequest(&data)

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "aws_account"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().CreateAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create aws_account, got error: %s", err))
		return
	}

	CopyCreateAwsAccountResponse(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "aws_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsAccountResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data AwsAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := NewReadAwsAccountRequest(&data)

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "aws_account", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().ReadAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No aws_account found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read aws_account, got error: %s", err))
			return
		}
	}

	CopyReadAwsAccountResponse(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "aws_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AwsAccountResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData AwsAccountResourceModel
	var afterData AwsAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := NewUpdateAwsAccountRequest(&beforeData, &afterData)

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "aws_account", "id": protoReq.Id, "update_mask": protoReq.UpdateMask.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().UpdateAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No aws_account found with id %s", protoReq.Id))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update aws_account, got error: %s", err))
			return
		}
	}

	CopyUpdateAwsAccountResponse(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "aws_account", "id": protoResp.Id})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *AwsAccountResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data AwsAccountResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := NewDeleteAwsAccountRequest(&data)

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "aws_account", "id": protoReq.Id})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().DeleteAwsAccount(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "aws_account", "id": protoReq.Id})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete aws_account, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "aws_account", "id": protoReq.Id})
}

func (r *AwsAccountResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}

type AwsAccountResourceModel struct {
	Id                types.String `tfsdk:"id"`
	AccountId         types.String `tfsdk:"account_id"`
	AccountType       types.String `tfsdk:"account_type"`
	Disabled          types.Bool   `tfsdk:"disabled"`
	ExcludedRegions   types.Set    `tfsdk:"excluded_regions"`
	ExcludedSubnetIds types.Set    `tfsdk:"excluded_subnet_ids"`
	ExcludedVpcIds    types.Set    `tfsdk:"excluded_vpc_ids"`
	Mode              types.String `tfsdk:"mode"`
	Name              types.String `tfsdk:"name"`
	ServiceAccountId  types.String `tfsdk:"service_account_id"`
}

func NewCreateAwsAccountRequest(data *AwsAccountResourceModel) *configv1.CreateAwsAccountRequest {
	proto := &configv1.CreateAwsAccountRequest{}
	if !data.AccountId.IsUnknown() && !data.AccountId.IsNull() {
		var dataValue attr.Value = data.AccountId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.AccountId = protoValue
	}
	if !data.AccountType.IsUnknown() && !data.AccountType.IsNull() {
		var dataValue attr.Value = data.AccountType
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.AccountType = protoValue
	}
	if !data.Disabled.IsUnknown() && !data.Disabled.IsNull() {
		var dataValue attr.Value = data.Disabled
		var protoValue bool
		protoValue = dataValue.(types.Bool).ValueBool()
		proto.Disabled = &protoValue
	}
	if !data.ExcludedRegions.IsUnknown() && !data.ExcludedRegions.IsNull() {
		var dataValue attr.Value = data.ExcludedRegions
		var protoValue []string
		{
			dataElements := dataValue.(types.Set).Elements()
			protoValues := make([]string, 0, len(dataElements))
			for _, dataElement := range dataElements {
				var dataValue attr.Value = dataElement
				var protoValue string
				protoValue = dataValue.(types.String).ValueString()
				protoValues = append(protoValues, protoValue)
			}
			protoValue = protoValues
		}
		proto.ExcludedRegions = protoValue
	}
	if !data.ExcludedSubnetIds.IsUnknown() && !data.ExcludedSubnetIds.IsNull() {
		var dataValue attr.Value = data.ExcludedSubnetIds
		var protoValue []string
		{
			dataElements := dataValue.(types.Set).Elements()
			protoValues := make([]string, 0, len(dataElements))
			for _, dataElement := range dataElements {
				var dataValue attr.Value = dataElement
				var protoValue string
				protoValue = dataValue.(types.String).ValueString()
				protoValues = append(protoValues, protoValue)
			}
			protoValue = protoValues
		}
		proto.ExcludedSubnetIds = protoValue
	}
	if !data.ExcludedVpcIds.IsUnknown() && !data.ExcludedVpcIds.IsNull() {
		var dataValue attr.Value = data.ExcludedVpcIds
		var protoValue []string
		{
			dataElements := dataValue.(types.Set).Elements()
			protoValues := make([]string, 0, len(dataElements))
			for _, dataElement := range dataElements {
				var dataValue attr.Value = dataElement
				var protoValue string
				protoValue = dataValue.(types.String).ValueString()
				protoValues = append(protoValues, protoValue)
			}
			protoValue = protoValues
		}
		proto.ExcludedVpcIds = protoValue
	}
	if !data.Mode.IsUnknown() && !data.Mode.IsNull() {
		var dataValue attr.Value = data.Mode
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Mode = &protoValue
	}
	if !data.Name.IsUnknown() && !data.Name.IsNull() {
		var dataValue attr.Value = data.Name
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Name = protoValue
	}
	if !data.ServiceAccountId.IsUnknown() && !data.ServiceAccountId.IsNull() {
		var dataValue attr.Value = data.ServiceAccountId
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.ServiceAccountId = protoValue
	}
	return proto
}

func NewReadAwsAccountRequest(data *AwsAccountResourceModel) *configv1.ReadAwsAccountRequest {
	proto := &configv1.ReadAwsAccountRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto
}

func NewDeleteAwsAccountRequest(data *AwsAccountResourceModel) *configv1.DeleteAwsAccountRequest {
	proto := &configv1.DeleteAwsAccountRequest{}
	if !data.Id.IsUnknown() && !data.Id.IsNull() {
		var dataValue attr.Value = data.Id
		var protoValue string
		protoValue = dataValue.(types.String).ValueString()
		proto.Id = protoValue
	}
	return proto
}

func NewUpdateAwsAccountRequest(beforeData, afterData *AwsAccountResourceModel) *configv1.UpdateAwsAccountRequest {
	proto := &configv1.UpdateAwsAccountRequest{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	if !afterData.ExcludedRegions.Equal(beforeData.ExcludedRegions) {
		proto.UpdateMask.Append(proto, "excluded_regions")
		if !afterData.ExcludedRegions.IsUnknown() && !afterData.ExcludedRegions.IsNull() {
			var dataValue attr.Value = afterData.ExcludedRegions
			var protoValue []string
			{
				dataElements := dataValue.(types.Set).Elements()
				protoValues := make([]string, 0, len(dataElements))
				for _, dataElement := range dataElements {
					var dataValue attr.Value = dataElement
					var protoValue string
					protoValue = dataValue.(types.String).ValueString()
					protoValues = append(protoValues, protoValue)
				}
				protoValue = protoValues
			}
			proto.ExcludedRegions = protoValue
		}
	}
	if !afterData.ExcludedSubnetIds.Equal(beforeData.ExcludedSubnetIds) {
		proto.UpdateMask.Append(proto, "excluded_subnet_ids")
		if !afterData.ExcludedSubnetIds.IsUnknown() && !afterData.ExcludedSubnetIds.IsNull() {
			var dataValue attr.Value = afterData.ExcludedSubnetIds
			var protoValue []string
			{
				dataElements := dataValue.(types.Set).Elements()
				protoValues := make([]string, 0, len(dataElements))
				for _, dataElement := range dataElements {
					var dataValue attr.Value = dataElement
					var protoValue string
					protoValue = dataValue.(types.String).ValueString()
					protoValues = append(protoValues, protoValue)
				}
				protoValue = protoValues
			}
			proto.ExcludedSubnetIds = protoValue
		}
	}
	if !afterData.ExcludedVpcIds.Equal(beforeData.ExcludedVpcIds) {
		proto.UpdateMask.Append(proto, "excluded_vpc_ids")
		if !afterData.ExcludedVpcIds.IsUnknown() && !afterData.ExcludedVpcIds.IsNull() {
			var dataValue attr.Value = afterData.ExcludedVpcIds
			var protoValue []string
			{
				dataElements := dataValue.(types.Set).Elements()
				protoValues := make([]string, 0, len(dataElements))
				for _, dataElement := range dataElements {
					var dataValue attr.Value = dataElement
					var protoValue string
					protoValue = dataValue.(types.String).ValueString()
					protoValues = append(protoValues, protoValue)
				}
				protoValue = protoValues
			}
			proto.ExcludedVpcIds = protoValue
		}
	}
	if !afterData.Name.Equal(beforeData.Name) {
		proto.UpdateMask.Append(proto, "name")
		if !afterData.Name.IsUnknown() && !afterData.Name.IsNull() {
			var dataValue attr.Value = afterData.Name
			var protoValue string
			protoValue = dataValue.(types.String).ValueString()
			proto.Name = protoValue
		}
	}
	return proto
}
func CopyCreateAwsAccountResponse(dst *AwsAccountResourceModel, src *configv1.CreateAwsAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.AccountType = types.StringValue(src.AccountType)
	dst.Disabled = types.BoolPointerValue(src.Disabled)
	{
		protoValue := src.ExcludedRegions
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedRegions = dataValue
	}
	{
		protoValue := src.ExcludedSubnetIds
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedSubnetIds = dataValue
	}
	{
		protoValue := src.ExcludedVpcIds
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedVpcIds = dataValue
	}
	dst.Mode = types.StringPointerValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.ServiceAccountId = types.StringValue(src.ServiceAccountId)
}
func CopyReadAwsAccountResponse(dst *AwsAccountResourceModel, src *configv1.ReadAwsAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.AccountType = types.StringValue(src.AccountType)
	dst.Disabled = types.BoolPointerValue(src.Disabled)
	{
		protoValue := src.ExcludedRegions
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedRegions = dataValue
	}
	{
		protoValue := src.ExcludedSubnetIds
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedSubnetIds = dataValue
	}
	{
		protoValue := src.ExcludedVpcIds
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedVpcIds = dataValue
	}
	dst.Mode = types.StringPointerValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.ServiceAccountId = types.StringValue(src.ServiceAccountId)
}
func CopyUpdateAwsAccountResponse(dst *AwsAccountResourceModel, src *configv1.UpdateAwsAccountResponse) {
	dst.Id = types.StringValue(src.Id)
	dst.AccountId = types.StringValue(src.AccountId)
	dst.AccountType = types.StringValue(src.AccountType)
	dst.Disabled = types.BoolPointerValue(src.Disabled)
	{
		protoValue := src.ExcludedRegions
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedRegions = dataValue
	}
	{
		protoValue := src.ExcludedSubnetIds
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedSubnetIds = dataValue
	}
	{
		protoValue := src.ExcludedVpcIds
		var dataValue types.Set
		{
			dataElementType := types.StringType
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.SetNull(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					var protoValue string = protoElement
					var dataValue attr.Value
					dataValue = types.StringValue(protoValue)
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.SetValueMust(dataElementType, dataValues)
			}
		}
		dst.ExcludedVpcIds = dataValue
	}
	dst.Mode = types.StringPointerValue(src.Mode)
	dst.Name = types.StringValue(src.Name)
	dst.ServiceAccountId = types.StringValue(src.ServiceAccountId)
}
