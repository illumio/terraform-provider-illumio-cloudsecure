// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0

package main

import (
	"fmt"
	"io"
	"sort"
	"text/template" // nosemgrep: go.lang.security.audit.xss.import-text-template.import-text-template

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/illumio/terraform-provider-illumio-cloudsecure/api/schema"
)

var (
	// providerTemplate is the template of the Terraform provider implementation for the Illumio CloudSecure Config API.
	providerTemplate = template.Must(template.New("providermodel").Parse(`// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0
// Code generated by providergen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	resource_schema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	{{- if  eq .HasObjectElementType true}}
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	configv1 "github.com/illumio/terraform-provider-illumio-cloudsecure/api/illumio/cloud/config/v1"
)

// ProviderData is the state of the provider, which is passed to resources and data sources at runtime as their ProviderData.
type ProviderData interface {
	// Client returns the CloudSecure Config API client.
	Client() configv1.ConfigServiceClient

	// RequestTimeout returns the maximum duration of each API request.
	RequestTimeout() time.Duration
}

func (p *{{.ProviderTypeName}}) Resources(ctx context.Context) []func() resource.Resource {
	resources := p.schema.Resources()
	resp := make([]func() resource.Resource, 0, len(resources))
	for _, r := range resources {
		switch r.TypeName {
		{{- range $resource := .Resources}}
		case "{{$resource.Name}}":
			resp = append(resp, func() resource.Resource { return New{{$resource.TypeName}}(r.Schema) })
		{{- end}}
		}
	}
	return resp
}

func (p *{{.ProviderTypeName}}) DataSources(ctx context.Context) []func() datasource.DataSource {
	return []func() datasource.DataSource{
		// TODO: Add support for data sources.
	}
}
{{- define "resource"}}

// {{.TypeName}} implements the {{.Name}} resource.
type {{.TypeName}} struct {
	// schema is the schema of the {{.Name}} resource.
	schema resource_schema.Schema

	// providerData is the provider configuration.
	config ProviderData
}

var _ resource.ResourceWithConfigure = &{{.TypeName}}{}
var _ resource.ResourceWithImportState = &{{.TypeName}}{}

// New{{.TypeName}} returns a new {{.Name}} resource.
func New{{.TypeName}}(schema resource_schema.Schema) resource.Resource {
	return &{{.TypeName}}{
		schema: schema,
	}
}

func (r *{{.TypeName}}) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{.Name}}"
}

func (r *{{.TypeName}}) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = r.schema
}

func (r *{{.TypeName}}) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.config = providerData
}

func (r *{{.TypeName}}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data {{.ModelName}}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := {{.NewCreateRequestFuncName}}(ctx, &data)

	tflog.Trace(ctx, "creating a resource", map[string]any{"type": "{{.Name}}"})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().{{.RPCNameForCreate}}(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
	    resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to create {{.Name}}, got error: %s", err))
	    return
	 }

	 {{.CopyCreateResponseFuncName}}(&data, protoResp)

	tflog.Trace(ctx, "created a resource", map[string]any{"type": "{{.Name}}", "id": protoResp.{{.IdFieldName}}})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{.TypeName}}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data {{.ModelName}}

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := {{.NewReadRequestFuncName}}(ctx, &data)

	tflog.Trace(ctx, "reading a resource", map[string]any{"type": "{{.Name}}", "id": protoReq.{{.IdFieldName}}})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().{{.RPCNameForRead}}(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddWarning("Resource Not Found", fmt.Sprintf("No {{.Name}} found with id %s", protoReq.{{.IdFieldName}}))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to read {{.Name}}, got error: %s", err))
			return
		}
	}

	{{.CopyReadResponseFuncName}}(&data, protoResp)

	tflog.Trace(ctx, "read a resource", map[string]any{"type": "{{.Name}}", "id": protoResp.{{.IdFieldName}}})

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{.TypeName}}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var beforeData {{.ModelName}}
	var afterData {{.ModelName}}

	resp.Diagnostics.Append(req.State.Get(ctx, &beforeData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &afterData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := {{.NewUpdateRequestFuncName}}(ctx, &beforeData, &afterData)

	tflog.Trace(ctx, "updating a resource", map[string]any{"type": "{{.Name}}", "id": protoReq.{{.IdFieldName}}, "update_mask": protoReq.{{.UpdateMaskFieldName}}.Paths})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	protoResp, err := r.config.Client().{{.RPCNameForUpdate}}(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			resp.Diagnostics.AddError("Resource Not Found", fmt.Sprintf("No {{.Name}} found with id %s", protoReq.{{.IdFieldName}}))
			resp.State.RemoveResource(ctx)
			return
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to update {{.Name}}, got error: %s", err))
			return
		}
	}

	{{.CopyUpdateResponseFuncName}}(&afterData, protoResp)

	tflog.Trace(ctx, "updated a resource", map[string]any{"type": "{{.Name}}", "id": protoResp.{{.IdFieldName}}})

	resp.Diagnostics.Append(resp.State.Set(ctx, &afterData)...)
}

func (r *{{.TypeName}}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data {{.ModelName}}

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	protoReq := {{.NewDeleteRequestFuncName}}(ctx, &data)

	tflog.Trace(ctx, "deleting a resource", map[string]any{"type": "{{.Name}}", "id": protoReq.{{.IdFieldName}}})

	rpcCtx, rpcCancel := context.WithTimeout(ctx, r.config.RequestTimeout())
	_, err := r.config.Client().{{.RPCNameForDelete}}(rpcCtx, protoReq)
	rpcCancel()
	if err != nil {
		switch status.Code(err) {
		case codes.NotFound:
			tflog.Trace(ctx, "resource was already deleted", map[string]any{"type": "{{.Name}}", "id": protoReq.{{.IdFieldName}}})
		default:
			resp.Diagnostics.AddError("Config API Error", fmt.Sprintf("Unable to delete {{.Name}}, got error: %s", err))
			return
		}
	}

	tflog.Trace(ctx, "deleted a resource", map[string]any{"type": "{{.Name}}", "id": protoReq.{{.IdFieldName}}})
}

func (r *{{.TypeName}}) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// TODO
}
{{- end}}
{{- range $resource := .Resources}}
{{- template "resource" $resource}}
{{- end}}
{{- define "model"}}

type {{.Name}} struct {
	{{- range $field := .Fields}}
	{{$field.Name}} types.{{$field.Type.ModelTypeName}} ` + "`" + `tfsdk:"{{$field.AttributeName}}"` + "`" + `
	{{- end}}
}
{{- end}}
{{- range $model := .Models}}
{{- template "model" $model}}
{{- end}}
{{- define "convertDataValueToProto"}}
	{{- if ne .NestedModel nil}}
		protoValue = ConvertDataValueTo{{.NestedModel.Name}}Proto(ctx, dataValue)
	{{- else if eq .CollectionElementType nil}}
		protoValue = dataValue.(types.{{.ModelTypeName}}).Value{{.ModelTypeName}}()
	{{- else}}
		{
			dataElements := dataValue.(types.{{.ModelTypeName}}).Elements()
			protoValues := make({{.ProtoTypeName}}, 0, len(dataElements))
			for _, dataElement := range dataElements {
				var dataValue attr.Value = dataElement
				{{- if eq .CollectionElementType.NestedModel nil}}
				var protoValue {{.CollectionElementType.ProtoTypeName}}
				{{- else}}
				var protoValue *{{.CollectionElementType.ProtoTypeName}}
				{{- end}}
				{{- template "convertDataValueToProto" .CollectionElementType}}
				protoValues = append(protoValues, {{if ne .WrapProtoValueElementExpr nil}}{{.WrapProtoValueElementExpr}}{{else}}protoValue{{end}})
			}
			protoValue = protoValues
		}
	{{- end}}
{{- end}}
{{- define "newRequestFunc"}}

func {{.Name}}(ctx context.Context, data *{{.ModelName}}) *configv1.{{.ProtoName}} {
	proto := &configv1.{{.ProtoName}}{}
	{{- range $field := .Fields}}
	if !data.{{$field.Name}}.IsUnknown() && !data.{{$field.Name}}.IsNull() {
		var dataValue attr.Value = data.{{$field.Name}}
		{{- if eq $field.Type.NestedModel nil}}
		var protoValue {{$field.Type.ProtoTypeName}}
		{{- else}}
		var protoValue *{{$field.Type.ProtoTypeName}}
		{{- end}}
		{{- template "convertDataValueToProto" $field.Type}}
		{{- if and ($field.Optional) (eq $field.Type.CollectionElementType nil)}}
		proto.{{$field.Name}} = &protoValue
		{{- else}}
		proto.{{$field.Name}} = protoValue
		{{- end}}
	}
	{{- end}}
	return proto
}
{{- end}}
{{- range $newRequestFunc := .NewRequestFuncs}}
{{- template "newRequestFunc" $newRequestFunc}}
{{- end}}
{{- define "newUpdateRequestFunc"}}

func {{.Name}}(ctx context.Context, beforeData, afterData *{{.ModelName}}) *configv1.{{.ProtoName}} {
	proto := &configv1.{{.ProtoName}}{}
	proto.UpdateMask, _ = fieldmaskpb.New(proto)
	proto.Id = beforeData.Id.ValueString()
	{{- range $field := .Fields}}
	{{- if ne $field.Name "Id" }}
	if !afterData.{{$field.Name}}.Equal(beforeData.{{$field.Name}}) {
		proto.UpdateMask.Append(proto, "{{$field.AttributeName}}")
		if !afterData.{{$field.Name}}.IsUnknown() && !afterData.{{$field.Name}}.IsNull() {
			var dataValue attr.Value = afterData.{{$field.Name}}
			{{- if eq $field.Type.NestedModel nil}}
			var protoValue {{$field.Type.ProtoTypeName}}
			{{- else}}
			var protoValue *{{$field.Type.ProtoTypeName}}
			{{- end}}
			{{- template "convertDataValueToProto" $field.Type}}
			{{- if and ($field.Optional) (eq $field.Type.CollectionElementType nil)}}
			proto.{{$field.Name}} = &protoValue
			{{- else}}
			proto.{{$field.Name}} = protoValue
			{{- end}}
		}
	}
	{{- end}}
	{{- end}}
	return proto
}
{{- end}}
{{- range $newUpdateRequestFunc := .NewUpdateRequestFuncs}}
{{- template "newUpdateRequestFunc" $newUpdateRequestFunc}}
{{- end}}
{{- define "modelDataType"}}
{{- if ne .NestedModel nil -}}
types.ObjectType{
	AttrTypes: GetTypeAttrsFor{{.NestedModel.Name}}(),
}
{{- else if eq .CollectionElementType nil -}}
types.{{.ModelTypeName}}Type
{{- else -}}
types.{{.ModelTypeName}}Type{ElemType: {{- template "modelDataType" .CollectionElementType -}}}
{{- end}}
{{- end}}
{{- define "convertRepeatedProtoValueToData"}}
	{{- if ne .NestedModel nil}}
		dataValue = Convert{{.NestedModel.Name}}ToObjectValueFromProto(protoValue)
	{{- else if eq .CollectionElementType nil}}
		dataValue = types.{{.ModelTypeName}}Value(protoValue)
	{{- else}}
		{
			dataElementType := {{template "modelDataType" .CollectionElementType}}
			protoElements := protoValue
			if protoElements == nil {
				dataValue = types.{{.ModelTypeName}}Null(dataElementType)
			} else {
				dataValues := make([]attr.Value, 0, len(protoElements))
				for _, protoElement := range protoElements {
					{{- if ne .CollectionElementType.NestedModel nil}}
					var protoValue *{{.CollectionElementType.ProtoTypeName}} = {{if ne .UnwrapProtoValueElementExpr nil}}{{.UnwrapProtoValueElementExpr}}{{else}}protoElement{{end}}
					{{- else}}	
					var protoValue {{.CollectionElementType.ProtoTypeName}} = {{if ne .UnwrapProtoValueElementExpr nil}}{{.UnwrapProtoValueElementExpr}}{{else}}protoElement{{end}}
					{{- end}}	
					var dataValue attr.Value
					{{- template "convertRepeatedProtoValueToData" .CollectionElementType}}
					dataValues = append(dataValues, dataValue)
				}
				dataValue = types.{{.ModelTypeName}}ValueMust(dataElementType, dataValues)
			}
		}
	{{- end}}
{{- end}}
{{- define "copyResponseFunc"}}
func {{.Name}}(dst *{{.ModelName}}, src *configv1.{{.ProtoName}}) {
	{{- range $field := .Fields}}
	{{- if ne $field.Type.NestedModel nil}}
		dst.{{$field.Name}} = Convert{{.Type.NestedModel.Name}}ToObjectValueFromProto(src.{{$field.Name}})
	{{- else if eq $field.Type.CollectionElementType nil}}
		{{- if .Optional}}
		dst.{{$field.Name}} = types.{{$field.Type.ModelTypeName}}PointerValue(src.{{$field.Name}})
		{{- else}}
		dst.{{$field.Name}} = types.{{$field.Type.ModelTypeName}}Value(src.{{$field.Name}})
		{{- end}}
	{{- else}}
	{
		protoValue := src.{{$field.Name}}
		var dataValue types.{{$field.Type.ModelTypeName}}
		{{- template "convertRepeatedProtoValueToData" $field.Type}}
		dst.{{$field.Name}} = dataValue
	}
	{{- end}}
	{{- end}}
}
{{- end}}
{{- range $copyResponseFunc := .CopyResponseFuncs}}
{{- template "copyResponseFunc" $copyResponseFunc}}
{{- end}}
`))
)

// providerTemplateData defines the model of a Terraform provider.
type providerTemplateData struct {
	// Package is the Golang package of the generated code.
	Package string

	// ProviderTypeName is the name of the Golang struct type that implements the Provider interface.
	ProviderTypeName string

	// Models is the list of Terraform model structs to define.
	Models []model

	// NewRequestFuncs is the list of functions that create new create/read/delete request Protocol Buffer messages from Terraform models.
	NewRequestFuncs []convertFunc

	// NewUpdateRequestFuncs is the list of functions that create new update request Protocol Buffer messages from Terraform models.
	NewUpdateRequestFuncs []convertFunc

	// CopyResponseFuncs is the list of functions that copy response Protocol Buffer messages into Terraform models.
	CopyResponseFuncs []convertFunc

	// Resources is the list of Terraform resources to define.
	Resources []resourceData

	// HasObjectElementType is true if the schema has an object element type.
	HasObjectElementType bool
}

// model defines the model of a Terraform resource or data source.
type model struct {
	// Name is the name of the model.
	Name string

	// Fields defines the fields in the model.
	Fields []field
}

// field defines a field in a model.
type field struct {
	// Name is the name of the field.
	Name string

	// AttributeName is the name of the Terraform attribute corresponding to the field.
	AttributeName string

	// Type is the type of the field.
	Type fieldType

	// Optional is true is the field is optional.
	Optional bool
}

// fieldType defines the type of a field.
//
// TODO: Support nested objects.
type fieldType struct {
	// ModelTypeName is the name of the Golang type of the field in the Terraform model, e.g., "Bool", "String", "List", "Set", etc.
	ModelTypeName string

	// ProtoTypeName is the name of the Golang type of the field in the Protocol Buffer message, e.g., "string" or "[]string".
	ProtoTypeName string

	// CollectionElementType is the type of the elements of the collection type.
	// nil if the type is a primitive type.
	CollectionElementType *fieldType

	// WrapProtoValueElementExpr is the Golang expression that wraps element value "protoValue" when converting model data of this type into Protocol Buffer.
	// If not set, defaults to "protoValue".
	WrapProtoValueElementExpr *string

	// UnwrapProtoValueElementExpr is the Golang expression that unwraps element value "protoElement" when a converting Protocol Buffer field into model data of this type.
	// If not set, defaults to "protoElement".
	UnwrapProtoValueElementExpr *string

	// NestedModel is the  nested model.
	// nil if the type is a primitive type.
	NestedModel *model
}

// convertFunc defines a function that converts Terraform models into Protocol Buffer messages or vice-versa.
type convertFunc struct {
	// Name is the name of the function.
	Name string

	// ProtoName is the name of the Protocol Buffer message.
	ProtoName string

	// ModelName is the name of the Terraform model.
	ModelName string

	// Fields defines the fields of the model to copy into the request message.
	Fields []field
}

// resourceData defines a Terraform resource.
type resourceData struct {
	// Name is the Terraform name of the resource.
	Name string

	// TypeName is the Golang struct type that implements the resource.
	TypeName string

	// ModelName is the name of the resource's model.
	ModelName string

	// IdFieldName is the CamelCased name of the attribute/field used as the ID for the resource.
	IdFieldName string

	// UpdateMaskFieldName is the CamelCased name of the attribute/field used in resource update requests to list the fields modified by the operation.
	UpdateMaskFieldName string

	// NewCreateRequestFuncName is the name of the function that creates a Protocol Buffer request message to create a resource.
	NewCreateRequestFuncName string

	// CopyCreateResponseFuncName is the name of the function that copies a Protocol Buffer response message after creating a resource.
	CopyCreateResponseFuncName string

	// NewReadRequestFuncName is the name of the function that creates a Protocol Buffer request message to read a resource.
	NewReadRequestFuncName string

	// CopyReadResponseFuncName is the name of the function that copies a Protocol Buffer response message after reading a resource.
	CopyReadResponseFuncName string

	// NewUpdateRequestFuncName is the name of the function that creates a Protocol Buffer request message to update a resource.
	NewUpdateRequestFuncName string

	// CopyUpdateResponseFuncName is the name of the function that copies a Protocol Buffer response message after updating a resource.
	CopyUpdateResponseFuncName string

	// NewDeleteRequestFuncName is the name of the function that creates a Protocol Buffer request message to delete a resource.
	NewDeleteRequestFuncName string

	// RPCNameForCreate is the name of the gRPC RPC used to create resources.
	RPCNameForCreate string

	// RPCNameForRead is the name of the gRPC RPC used to read resources.
	RPCNameForRead string

	// RPCNameForUpdate is the name of the gRPC RPC used to update resources.
	RPCNameForUpdate string

	// RPCNameForDelete is the name of the gRPC RPC used to delete resources.
	RPCNameForDelete string
}

// GenerateProvider generates the implementation of the Terraform provider for the given schema.
func GenerateProvider(dst io.Writer, pkg string, src schema.Schema) error {
	data := providerTemplateData{
		Package:               pkg,
		ProviderTypeName:      "Provider",
		Models:                make([]model, 0, len(src.Resources())),
		NewRequestFuncs:       make([]convertFunc, 0, len(src.Resources())*3),
		NewUpdateRequestFuncs: make([]convertFunc, 0, len(src.Resources())),
		CopyResponseFuncs:     make([]convertFunc, 0, len(src.Resources())*3),
		Resources:             make([]resourceData, 0, len(src.Resources())),
	}

	camelCasedIdFieldName := schema.ProtoMessageName(schema.IDFieldName)
	camelCasedUpdateMaskFieldName := schema.ProtoMessageName(schema.UpdateMaskFieldName)

	for _, resource := range src.Resources() {
		err := AddResourceToProviderTemplateData(&resource, &data, camelCasedIdFieldName, camelCasedUpdateMaskFieldName)
		if err != nil {
			return err
		}

	}

	err := providerTemplate.Execute(dst, &data)
	if err != nil {
		return err
	}

	return ProviderConvertersTemplate.Execute(dst, &data)
}

func AddResourceToProviderTemplateData(resource *schema.Resource, data *providerTemplateData, camelCasedIdFieldName, camelCasedUpdateMaskFieldName string) error {
	resourceName := resource.TypeName
	resourceMessageName := schema.ProtoMessageName(resourceName)
	numFields := len(resource.Schema.Attributes)

	resourceModel := model{
		Name:   resourceMessageName + "ResourceModel",
		Fields: make([]field, 0, numFields),
	}

	createRequestFunc := convertFunc{
		Name:      "New" + schema.ProtoMessageNameForCreateRequest(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForCreateRequest(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, numFields-1),
	}

	readRequestFunc := convertFunc{
		Name:      "New" + schema.ProtoMessageNameForReadRequest(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForReadRequest(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, 1),
	}

	updateRequestFunc := convertFunc{
		Name:      "New" + schema.ProtoMessageNameForUpdateRequest(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForUpdateRequest(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, numFields+1),
	}

	deleteRequestFunc := convertFunc{
		Name:      "New" + schema.ProtoMessageNameForDeleteRequest(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForDeleteRequest(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, 1),
	}

	createResponseFunc := convertFunc{
		Name:      "Copy" + schema.ProtoMessageNameForCreateResponse(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForCreateResponse(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, numFields),
	}

	readResponseFunc := convertFunc{
		Name:      "Copy" + schema.ProtoMessageNameForReadResponse(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForReadResponse(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, numFields),
	}

	updateResponseFunc := convertFunc{
		Name:      "Copy" + schema.ProtoMessageNameForUpdateResponse(resourceMessageName),
		ProtoName: schema.ProtoMessageNameForUpdateResponse(resourceMessageName),
		ModelName: resourceModel.Name,
		Fields:    make([]field, 0, numFields),
	}

	attrNames := schema.SortResourceAttributes(resource.Schema.Attributes)
	for _, attrName := range attrNames {
		attrSchema := resource.Schema.Attributes[attrName]

		t, err := TerraformAttributeTypeToProtoType("configv1."+resourceMessageName, attrName, attrSchema.GetType(), true)
		if err != nil {
			return fmt.Errorf("failed to parse field %s in resource %s: %w", attrName, resourceMessageName, err)
		}

		if t.NestedModel != nil {
			data.HasObjectElementType = true
		}

		f := field{
			Name:          schema.ProtoMessageName(attrName),
			AttributeName: attrName,
			Type:          t,
			Optional:      schema.AttributeIsOptional(attrSchema),
		}

		resourceModel.Fields = append(resourceModel.Fields, f)

		mode := schema.GetResourceAttributeMode(attrSchema)

		if mode.InCreateRequest {
			createRequestFunc.Fields = append(createRequestFunc.Fields, f)
		}

		if mode.InCreateResponse {
			createResponseFunc.Fields = append(createResponseFunc.Fields, f)
		}

		if mode.InReadRequest {
			readRequestFunc.Fields = append(readRequestFunc.Fields, f)
		}

		if mode.InReadResponse {
			readResponseFunc.Fields = append(readResponseFunc.Fields, f)
		}

		if mode.InUpdateRequest {
			updateRequestFunc.Fields = append(updateRequestFunc.Fields, f)
		}

		if mode.InUpdateResponse {
			updateResponseFunc.Fields = append(updateResponseFunc.Fields, f)
		}

		if mode.InDeleteRequest {
			deleteRequestFunc.Fields = append(deleteRequestFunc.Fields, f)
		}
	}

	data.Models = append(data.Models,
		resourceModel,
	)
	data.NewRequestFuncs = append(data.NewRequestFuncs,
		createRequestFunc,
		readRequestFunc,
		deleteRequestFunc,
	)
	data.NewUpdateRequestFuncs = append(data.NewUpdateRequestFuncs,
		updateRequestFunc,
	)
	data.CopyResponseFuncs = append(data.CopyResponseFuncs,
		createResponseFunc,
		readResponseFunc,
		updateResponseFunc,
	)

	data.Resources = append(data.Resources, resourceData{
		Name:                       resourceName,
		TypeName:                   resourceMessageName + "Resource",
		ModelName:                  resourceModel.Name,
		IdFieldName:                camelCasedIdFieldName,
		UpdateMaskFieldName:        camelCasedUpdateMaskFieldName,
		NewCreateRequestFuncName:   createRequestFunc.Name,
		CopyCreateResponseFuncName: createResponseFunc.Name,
		NewReadRequestFuncName:     readRequestFunc.Name,
		CopyReadResponseFuncName:   readResponseFunc.Name,
		NewUpdateRequestFuncName:   updateRequestFunc.Name,
		CopyUpdateResponseFuncName: updateResponseFunc.Name,
		NewDeleteRequestFuncName:   deleteRequestFunc.Name,
		RPCNameForCreate:           schema.RPCNameForCreate(resourceMessageName),
		RPCNameForRead:             schema.RPCNameForRead(resourceMessageName),
		RPCNameForUpdate:           schema.RPCNameForUpdate(resourceMessageName),
		RPCNameForDelete:           schema.RPCNameForDelete(resourceMessageName),
	})
	return nil
}

// TerraformAttributeTypeToProtoType converts a Terraform attribute type into the corresponding Protocol Buffer Golang type.
func TerraformAttributeTypeToProtoType(nestedMessageNamePrefix, attrName string, attrType attr.Type, isRoot bool) (t fieldType, err error) {
	switch v := attrType.(type) {
	case basetypes.BoolType:
		return fieldType{
			ModelTypeName: "Bool",
			ProtoTypeName: "bool",
		}, nil
	case basetypes.Float64Type:
		return fieldType{
			ModelTypeName: "Float64",
			ProtoTypeName: "float64",
		}, nil
	case basetypes.Int64Type:
		return fieldType{
			ModelTypeName: "Int64",
			ProtoTypeName: "int64",
		}, nil
	case basetypes.StringType:
		return fieldType{
			ModelTypeName: "String",
			ProtoTypeName: "string",
		}, nil
	case types.ListType:
		protoTypeName, wrapProtoValueElementExpr, unwrapProtoValueElementExpr, elementProtoType, err := TerraformRepeatedAttributeTypeToProtoType(nestedMessageNamePrefix, attrName, v.ElementType())
		if err != nil {
			return fieldType{}, err
		}

		return fieldType{
			ModelTypeName:               "List",
			ProtoTypeName:               protoTypeName,
			CollectionElementType:       &elementProtoType,
			WrapProtoValueElementExpr:   wrapProtoValueElementExpr,
			UnwrapProtoValueElementExpr: unwrapProtoValueElementExpr,
		}, nil
	case types.SetType:
		protoTypeName, wrapProtoValueElementExpr, unwrapProtoValueElementExpr, elementProtoType, err := TerraformRepeatedAttributeTypeToProtoType(nestedMessageNamePrefix, attrName, v.ElementType())
		if err != nil {
			return fieldType{}, err
		}

		return fieldType{
			ModelTypeName:               "Set",
			ProtoTypeName:               protoTypeName,
			CollectionElementType:       &elementProtoType,
			WrapProtoValueElementExpr:   wrapProtoValueElementExpr,
			UnwrapProtoValueElementExpr: unwrapProtoValueElementExpr,
		}, nil
	case types.ObjectType:
		protoTypeName, objModel, err := TerraformObjectAttributeTypeToProtoType(nestedMessageNamePrefix, attrName, v, isRoot)
		if err != nil {
			return fieldType{}, err
		}

		return fieldType{
			ModelTypeName: "Object",
			ProtoTypeName: protoTypeName,
			NestedModel:   objModel,
		}, nil
	default:
		return fieldType{}, fmt.Errorf("unsupported Terraform type: %s", attrType.String())
	}
}

func TerraformObjectAttributeTypeToProtoType(nestedMessageNamePrefix, attrName string, object types.ObjectType, isRoot bool) (protoTypeName string, nestedModel *model, err error) {
	protoAttrName := schema.ProtoMessageName(attrName)
	fields := make([]field, 0, len(object.AttrTypes))
	wrappedMessageName := nestedMessageNamePrefix + "_" + protoAttrName

	for fieldName, fieldType := range object.AttrTypes {
		t, err := TerraformAttributeTypeToProtoType(wrappedMessageName, fieldName, fieldType, true)
		if err != nil {
			return "", nil, fmt.Errorf("failed to parse field %s in object %s: %w", fieldName, nestedMessageNamePrefix, err)
		}

		fields = append(fields, field{
			Name:          schema.ProtoMessageName(fieldName),
			AttributeName: fieldName,
			Type:          t,
			Optional:      true,
		})
	}

	// reorder fields Sort by Name
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].Name < fields[j].Name
	})

	if isRoot {
		nestedMessageNamePrefix += "_" + schema.ProtoMessageName(attrName)
	}

	dataModel := model{
		Name:   nestedMessageNamePrefix[9:],
		Fields: fields,
	}

	return nestedMessageNamePrefix, &dataModel, nil
}

func TerraformRepeatedAttributeTypeToProtoType(nestedMessageNamePrefix, attrName string, elementType attr.Type) (protoTypeName string, wrapProtoValueElementExpr, unwrapProtoValueElementExpr *string, elemProtoType fieldType, err error) {
	camelCasedAttrName := schema.ProtoMessageName(attrName)
	wrapperMessageName := nestedMessageNamePrefix + "_" + camelCasedAttrName

	elemType, err := TerraformAttributeTypeToProtoType(wrapperMessageName, attrName, elementType, false)

	switch {
	case err != nil:
		return "", nil, nil, fieldType{}, fmt.Errorf("unsupported element type %s: %w", elementType.String(), err)
	case elemType.NestedModel != nil: // The element type itself is a nested object. Every element is wrapped into a nested Protocol Buffer message.
		return "[]*" + wrapperMessageName, nil, nil, elemType, nil
	case elemType.CollectionElementType != nil: // The element type itself is repeated. Every element is wrapped into a nested Protocol Buffer message.
		wrapProtoValueElementExpr := fmt.Sprintf("&%s{%s:protoValue}", wrapperMessageName, camelCasedAttrName)
		unwrapProtoValueElementExpr := "protoElement." + camelCasedAttrName

		return "[]*" + wrapperMessageName, &wrapProtoValueElementExpr, &unwrapProtoValueElementExpr, elemType, nil

	default: // The element type is not repeated. Normal case.
		return "[]" + elemType.ProtoTypeName, nil, nil, elemType, nil
	}
}
