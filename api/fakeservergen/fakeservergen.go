// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0

package main

import (
	"fmt"
	"io"
	"text/template"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/illumio/terraform-provider-illumio-cloudsecure/api/schema"
)

var (
	// fakeServerTemplate is the template of a fake server implementing Illumio CloudSecure Config API.
	fakeServerTemplate = template.Must(template.New("fakeserver").Parse(`// Copyright (c) Illumio, Inc.
// SPDX-License-Identifier: MPL-2.0
// Code generated by fakeservergen. DO NOT EDIT.
	
package {{.Package}}

import (
	"context"
	"sync"

	"github.com/google/uuid"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
	"go.uber.org/zap"
	configv1 "github.com/illumio/terraform-provider-illumio-cloudsecure/api/illumio/cloud/config/v1"
)

// {{.ServerTypeName}} is a fake server implementation of ConfigService that can be used for testing API clients.
type {{.ServerTypeName}} struct {
	configv1.UnimplementedConfigServiceServer
	Logger *zap.Logger
	{{- range $model := .Models}}
	{{- with $model}}
	{{.Name}}Map map[string]*{{.Name}}
	{{.Name}}Mutex sync.RWMutex
	{{- end}}
	{{- end}}
}

var _ configv1.ConfigServiceServer = &{{.ServerTypeName}}{}

// New{{.ServerTypeName}} creates a fake server implementation of ConfigService that can be used for testing API clients.
func New{{.ServerTypeName}}(logger *zap.Logger) configv1.ConfigServiceServer {
	return &{{.ServerTypeName}}{
		Logger: logger,
		{{- range $model := .Models}}
		{{- with $model}}
		{{.Name}}Map: make(map[string]*{{.Name}}),
		{{- end}}
		{{- end}}
	}
}
{{- range $model := .Models}}
{{- with $model}}

type {{.Name}} struct {
	{{- range $field := .Fields}}
	{{- with $field}}
	{{.Name}} {{.Type}}
	{{- end}}
	{{- end}}
}
{{- end}}
{{- end}}
{{- range $resource := .Resources}}
func (s *{{.ServerTypeName}}) {{$resource.CreateRPC.Name}}(ctx context.Context, req *configv1.{{$resource.CreateRPC.RequestMessage.Name}}) (*configv1.{{$resource.CreateRPC.ResponseMessage.Name}}, error) {
	id := uuid.New().String()
	model := &{{$resource.ModelName}}{
		{{.IdFieldName}}: id,
		{{- range $field := $resource.CreateRPC.RequestMessage.Fields}}
		{{$field.Name}}: req.{{$field.Name}},
		{{- end}}
	}
	resp := &configv1.{{$resource.CreateRPC.ResponseMessage.Name}}{
		{{.IdFieldName}}: id,
		{{- range $field := $resource.CreateRPC.ResponseMessage.Fields}}
		{{$field.Name}}: model.{{$field.Name}},
		{{- end}}
	}
	s.{{$resource.ModelName}}Mutex.Lock()
	s.{{$resource.ModelName}}Map[id] = model
	s.{{$resource.ModelName}}Mutex.Unlock()
	s.Logger.Info("created resource",
		zap.String("type", "{{$resource.Name}}"),
		zap.String("method", "{{$resource.CreateRPC.Name}}"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *{{.ServerTypeName}}) {{$resource.ReadRPC.Name}}(ctx context.Context, req *configv1.{{$resource.ReadRPC.RequestMessage.Name}}) (*configv1.{{$resource.ReadRPC.ResponseMessage.Name}}, error) {
	id := req.{{.IdFieldName}}
	s.{{$resource.ModelName}}Mutex.RLock()
	model, found := s.{{$resource.ModelName}}Map[id]
	if !found {
		s.{{$resource.ModelName}}Mutex.RUnlock()
		s.Logger.Error("attempted to read resource with unknown id",
			zap.String("type", "{{$resource.Name}}"),
			zap.String("method", "{{$resource.ReadRPC.Name}}"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no {{$resource.Name}} found with id %s", id)
	}
	resp := &configv1.{{$resource.ReadRPC.ResponseMessage.Name}}{
		{{.IdFieldName}}: id,
		{{- range $field := $resource.ReadRPC.ResponseMessage.Fields}}
		{{$field.Name}}: model.{{$field.Name}},
		{{- end}}
	}
	s.{{$resource.ModelName}}Mutex.RUnlock()
	s.Logger.Info("read resource",
		zap.String("type", "{{$resource.Name}}"),
		zap.String("method", "{{$resource.ReadRPC.Name}}"),
		zap.String("id", id),
	)
	return resp, nil
}

func (s *{{.ServerTypeName}}) {{$resource.UpdateRPC.Name}}(ctx context.Context, req *configv1.{{$resource.UpdateRPC.RequestMessage.Name}}) (*configv1.{{$resource.UpdateRPC.ResponseMessage.Name}}, error) {
	id := req.{{.IdFieldName}}
	s.{{$resource.ModelName}}Mutex.Lock()
	model, found := s.{{$resource.ModelName}}Map[id]
	if !found {
		s.{{$resource.ModelName}}Mutex.Unlock()
		s.Logger.Error("attempted to update resource with unknown id",
			zap.String("type", "{{$resource.Name}}"),
			zap.String("method", "{{$resource.UpdateRPC.Name}}"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no {{$resource.Name}} found with id %s", id)
	}
	updateMask := req.{{.UpdateMaskFieldName}}
	var updateMaskPaths []string
	if updateMask != nil {
		updateMaskPaths = updateMask.Paths
	}
	for _, path := range updateMaskPaths {
		switch path {
		{{- range $field := $resource.UpdateRPC.RequestMessage.Fields}}
		case "{{$field.AttributeName}}":
			model.{{$field.Name}} = req.{{$field.Name}}
		{{- end}}
		default:
			s.AwsAccountMutex.Unlock()
			s.Logger.Error("attempted to update resource using invalid update_mask path",
				zap.String("type", "{{$resource.Name}}"),
				zap.String("method", "{{$resource.UpdateRPC.Name}}"),
				zap.String("id", id),
				zap.Strings("updateMaskPaths", updateMaskPaths),
				zap.String("invalidUpdateMaskPath", path),
			)
			return nil, status.Errorf(codes.InvalidArgument, "invalid path in update_mask for aws_account: %s", path)
		}
	}
	resp := &configv1.{{$resource.UpdateRPC.ResponseMessage.Name}}{
		{{.IdFieldName}}: id,
		{{- range $field := $resource.UpdateRPC.ResponseMessage.Fields}}
		{{$field.Name}}: model.{{$field.Name}},
		{{- end}}
	}
	s.{{$resource.ModelName}}Mutex.Unlock()
	s.Logger.Info("updated resource",
		zap.String("type", "{{$resource.Name}}"),
		zap.String("method", "{{$resource.UpdateRPC.Name}}"),
		zap.String("id", id),
		zap.Strings("updateMaskPaths", updateMaskPaths),
	)
	return resp, nil
}

func (s *{{.ServerTypeName}}) {{$resource.DeleteRPC.Name}}(ctx context.Context, req *configv1.{{$resource.DeleteRPC.RequestMessage.Name}}) (*emptypb.Empty, error) {
	id := req.{{.IdFieldName}}
	s.{{$resource.ModelName}}Mutex.Lock()
	_, found := s.{{$resource.ModelName}}Map[id]
	if !found {
		s.{{$resource.ModelName}}Mutex.Unlock()
		s.Logger.Error("attempted to delete resource with unknown id",
			zap.String("type", "{{$resource.Name}}"),
			zap.String("method", "{{$resource.DeleteRPC.Name}}"),
			zap.String("id", id),
		)
		return nil, status.Errorf(codes.NotFound, "no {{$resource.Name}} found with id %s", id)
	}
	delete(s.{{$resource.ModelName}}Map, id)
	s.{{$resource.ModelName}}Mutex.Unlock()
	s.Logger.Info("deleted resource",
		zap.String("type", "{{$resource.Name}}"),
		zap.String("method", "{{$resource.DeleteRPC.Name}}"),
		zap.String("id", id),
	)
	return &emptypb.Empty{}, nil
}
{{- end}}
`))
)

// fakeServerTemplateData contains all the data needed to execute the fakeServerTemplate to generate the implementation of a fake ConfigServer.
type fakeServerTemplateData struct {
	// Package is the Golang package of the generated code.
	Package string

	// ServerTypeName is the name of the Golang struct type that implements the ConfigServer interface.
	ServerTypeName string

	// Models is the list of Terraform model structs to define.
	Models []model

	// Resources is the list of Terraform resources accessible via the ConfigServer interface.
	Resources []resourceData
}

// model defines the model of a Terraform resource or data source.
type model struct {
	// Name is the name of the model.
	Name string

	// Fields defines the fields in the model.
	Fields []field
}

// field defines a field in a model.
type field struct {
	// Name is the name of the field.
	Name string

	// AttributeName is the name of the Terraform attribute corresponding to the field.
	AttributeName string

	// Type is the Golang type of the field.
	Type string
}

// resourceData defines a Terraform resource.
type resourceData struct {
	// Name is the Terraform name of the resource.
	Name string

	// ModelName is the name of the resource's model.
	ModelName string

	// ServerTypeName is the name of the Golang struct type that implements the ConfigServer interface.
	ServerTypeName string

	// IdFieldName is the CamelCased name of the attribute/field used as the ID for the resource.
	IdFieldName string

	// UpdateMaskFieldName is the CamelCased name of the attribute/field used in resource update requests to list the fields modified by the operation.
	UpdateMaskFieldName string

	// CreateRPC defines the Create RPC for this resource.
	CreateRPC rpc

	// ReadRPC defines the Read RPC for this resource.
	ReadRPC rpc

	// UpdateRPC defines the Update RPC for this resource.
	UpdateRPC rpc

	// DeleteRPC defines the Delete RPC for this resource.
	DeleteRPC rpc
}

// rpc defines a gRPC RPC.
type rpc struct {
	// Name is the name of the gRPC RPC.
	Name string

	// RequestMessage is the RPC's request Protocol Buffer message.
	RequestMessage message

	// ResponseMessage is the RPC's response Protocol Buffer message.
	ResponseMessage message
}

// message is the definition of a Protocol Buffer message.
type message struct {
	// Name is the message name.
	Name string

	// Fields is the list of fields in the message.
	Fields []field
}

// GenerateFakeServer generates the implementation of a fake ConfigServer.
func GenerateFakeServer(dst io.Writer, pkg string, src schema.Schema) error {
	data := fakeServerTemplateData{
		Package:        pkg,
		ServerTypeName: "FakeConfigServer",
		Models:         make([]model, 0, len(src.Resources())),
	}

	camelCasedIdFieldName := schema.ProtoMessageName(schema.IdFieldName)
	camelCasedUpdateMaskFieldName := schema.ProtoMessageName(schema.UpdateMaskFieldName)

	for _, resource := range src.Resources() {
		resourceName := resource.TypeName
		resourceMessageName := schema.ProtoMessageName(resourceName)
		numFields := len(resource.Schema.Attributes)

		resourceModel := model{
			Name:   resourceMessageName,
			Fields: make([]field, 0, numFields),
		}

		res := resourceData{
			Name:                resourceName,
			ModelName:           resourceModel.Name,
			ServerTypeName:      data.ServerTypeName,
			IdFieldName:         camelCasedIdFieldName,
			UpdateMaskFieldName: camelCasedUpdateMaskFieldName,
			CreateRPC: rpc{
				Name: schema.RPCNameForCreate(resourceMessageName),
				RequestMessage: message{
					Name:   schema.ProtoMessageNameForCreateRequest(resourceMessageName),
					Fields: make([]field, 0, numFields-1),
				},
				ResponseMessage: message{
					Name:   schema.ProtoMessageNameForCreateResponse(resourceMessageName),
					Fields: make([]field, 0, numFields),
				},
			},
			ReadRPC: rpc{
				Name: schema.RPCNameForRead(resourceMessageName),
				RequestMessage: message{
					Name: schema.ProtoMessageNameForReadRequest(resourceMessageName),
					// No fields besides "id".
				},
				ResponseMessage: message{
					Name:   schema.ProtoMessageNameForReadResponse(resourceMessageName),
					Fields: make([]field, 0, numFields),
				},
			},
			UpdateRPC: rpc{
				Name: schema.RPCNameForUpdate(resourceMessageName),
				RequestMessage: message{
					Name:   schema.ProtoMessageNameForUpdateRequest(resourceMessageName),
					Fields: make([]field, 0, numFields),
				},
				ResponseMessage: message{
					Name:   schema.ProtoMessageNameForUpdateResponse(resourceMessageName),
					Fields: make([]field, 0, numFields),
				},
			},
			DeleteRPC: rpc{
				Name: schema.RPCNameForDelete(resourceMessageName),
				RequestMessage: message{
					Name: schema.ProtoMessageNameForDeleteRequest(resourceMessageName),
					// No fields besides "id".
				},
			},
		}
		attrNames := schema.SortResourceAttributes(resource.Schema.Attributes)
		for _, attrName := range attrNames {
			attrSchema := resource.Schema.Attributes[attrName]

			t, err := TerraformAttributeTypeToProtoType("configv1."+resourceMessageName, attrName, attrSchema.GetType(), attrSchema.IsOptional())
			if err != nil {
				return fmt.Errorf("failed to parse field %s in resource %s: %w", attrName, resourceMessageName, err)
			}

			f := field{
				Name:          schema.ProtoMessageName(attrName),
				AttributeName: attrName,
				Type:          t,
			}

			resourceModel.Fields = append(resourceModel.Fields, f)

			mode := schema.GetAttributeMode(attrSchema)

			// "id" is handled specially by the fake server, since it's used for looking up resources, etc.
			if f.AttributeName == schema.IdFieldName {
				continue
			}

			if mode.InCreateRequest {
				res.CreateRPC.RequestMessage.Fields = append(res.CreateRPC.RequestMessage.Fields, f)
			}
			if mode.InCreateResponse {
				res.CreateRPC.ResponseMessage.Fields = append(res.CreateRPC.ResponseMessage.Fields, f)
			}
			if mode.InReadResponse {
				res.ReadRPC.ResponseMessage.Fields = append(res.ReadRPC.ResponseMessage.Fields, f)
			}
			if mode.InUpdateRequest {
				res.UpdateRPC.RequestMessage.Fields = append(res.UpdateRPC.RequestMessage.Fields, f)
			}
			if mode.InUpdateResponse {
				res.UpdateRPC.ResponseMessage.Fields = append(res.UpdateRPC.ResponseMessage.Fields, f)
			}
		}

		data.Models = append(data.Models,
			resourceModel,
		)

		data.Resources = append(data.Resources, res)
	}

	return fakeServerTemplate.Execute(dst, &data)
}

// TerraformAttributeTypeToProtoType converts a Terraform attribute type into the corresponding Protocol Buffer Golang type.
func TerraformAttributeTypeToProtoType(nestedMessageNamePrefix, attrName string, attrType attr.Type, optional bool) (t string, err error) {
	switch v := attrType.(type) {
	case basetypes.BoolType:
		if optional {
			return "*bool", nil
		} else {
			return "bool", nil
		}
	case basetypes.Float64Type:
		if optional {
			return "*float64", nil
		} else {
			return "float64", nil
		}
	case basetypes.Int64Type:
		if optional {
			return "*int64", nil
		} else {
			return "int64", nil
		}
	case basetypes.StringType:
		if optional {
			return "*string", nil
		} else {
			return "string", nil
		}
	case types.ListType:
		return TerraformRepeatedAttributeTypeToProtoType(nestedMessageNamePrefix, attrName, v.ElementType())
	case types.SetType:
		return TerraformRepeatedAttributeTypeToProtoType(nestedMessageNamePrefix, attrName, v.ElementType())
	// TODO: Add support for nested objects.
	default:
		return "", fmt.Errorf("unsupported Terraform type: %s", attrType.String())
	}
}

func TerraformRepeatedAttributeTypeToProtoType(nestedMessageNamePrefix, attrName string, elementType attr.Type) (t string, err error) {
	elementTypeIsRepeated := false
	switch elementType.(type) {
	case types.ListType:
		elementTypeIsRepeated = true
	case types.SetType:
		elementTypeIsRepeated = true
	}

	if elementTypeIsRepeated { // The element type itself repeated. Every element is wrapped into a nested Protocol Buffer message.
		return "[]*" + nestedMessageNamePrefix + "_" + schema.ProtoMessageName(attrName), nil
	} else {
		elemType, err := TerraformAttributeTypeToProtoType(nestedMessageNamePrefix, attrName, elementType, false)
		if err != nil {
			return "", fmt.Errorf("unsupported element type %s: %w", elementType.String(), err)
		}
		return "[]" + elemType, nil
	}
}
